## File: `wearspace_app\alembic\env.py`

```
"""Pyramid bootstrap environment. """
from alembic import context
from pyramid.paster import get_appsettings, setup_logging
from sqlalchemy import engine_from_config

from wearspace_app.models.meta import Base

config = context.config

setup_logging(config.config_file_name)

settings = get_appsettings(config.config_file_name)
target_metadata = Base.metadata


def run_migrations_offline():
    """Run migrations in 'offline' mode.

    This configures the context with just a URL
    and not an Engine, though an Engine is acceptable
    here as well.  By skipping the Engine creation
    we don't even need a DBAPI to be available.

    Calls to context.execute() here emit the given string to the
    script output.

    """
    context.configure(url=settings['sqlalchemy.url'])
    with context.begin_transaction():
        context.run_migrations()


def run_migrations_online():
    """Run migrations in 'online' mode.

    In this scenario we need to create an Engine
    and associate a connection with the context.

    """
    engine = engine_from_config(settings, prefix='sqlalchemy.')

    connection = engine.connect()
    context.configure(
        connection=connection,
        target_metadata=target_metadata
    )

    try:
        with context.begin_transaction():
            context.run_migrations()
    finally:
        connection.close()


if context.is_offline_mode():
    run_migrations_offline()
else:
    run_migrations_online()

```

## File: `wearspace_app\alembic\script.py.mako`

```
"""${message}

Revision ID: ${up_revision}
Revises: ${down_revision | comma,n}
Create Date: ${create_date}

"""
from alembic import op
import sqlalchemy as sa
${imports if imports else ""}

# revision identifiers, used by Alembic.
revision = ${repr(up_revision)}
down_revision = ${repr(down_revision)}
branch_labels = ${repr(branch_labels)}
depends_on = ${repr(depends_on)}


def upgrade():
    ${upgrades if upgrades else "pass"}


def downgrade():
    ${downgrades if downgrades else "pass"}

```

## File: `wearspace_app\alembic\versions\20250527_294e4f48bbcd.py`

```
"""create wearspace tabel

Revision ID: 294e4f48bbcd
Revises:
Create Date: 2025-05-27 20:39:23.791326

"""
from alembic import op
import sqlalchemy as sa
from sqlalchemy.dialects import postgresql

# --- THIS IS THE CRUCIAL LINE YOU NEED TO ADD ---
from wearspace_app.models.meta import UUIDColumn
# -------------------------------------------------


# revision identifiers, used by Alembic.
revision = '294e4f48bbcd'
down_revision = None
branch_labels = None
depends_on = None


def upgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table('brands',
    sa.Column('id', UUIDColumn(length=36), nullable=False), # Changed: directly use UUIDColumn
    sa.Column('name', sa.String(length=255), nullable=False),
    sa.Column('created_at', sa.DateTime(timezone=True), server_default=sa.text('now()'), nullable=True),
    sa.Column('updated_at', sa.DateTime(timezone=True), nullable=True),
    sa.PrimaryKeyConstraint('id', name=op.f('pk_brands')),
    sa.UniqueConstraint('name', name=op.f('uq_brands_name'))
    )
    op.create_table('inspirations',
    sa.Column('id', UUIDColumn(length=36), nullable=False), # Changed: directly use UUIDColumn
    sa.Column('title', sa.String(length=255), nullable=False),
    sa.Column('description', sa.Text(), nullable=True),
    sa.Column('image_url', sa.String(length=255), nullable=True),
    sa.Column('tag', sa.String(length=100), nullable=True),
    sa.Column('created_at', sa.DateTime(timezone=True), server_default=sa.text('now()'), nullable=True),
    sa.Column('updated_at', sa.DateTime(timezone=True), nullable=True),
    sa.PrimaryKeyConstraint('id', name=op.f('pk_inspirations'))
    )
    op.create_table('users',
    sa.Column('id', UUIDColumn(length=36), nullable=False), # Changed: directly use UUIDColumn
    sa.Column('email', sa.String(length=255), nullable=False),
    sa.Column('hashed_password', sa.String(length=255), nullable=False),
    sa.Column('phone', sa.String(length=20), nullable=True),
    sa.Column('address', sa.Text(), nullable=True),
    sa.Column('created_at', sa.DateTime(timezone=True), server_default=sa.text('now()'), nullable=True),
    sa.Column('updated_at', sa.DateTime(timezone=True), nullable=True),
    sa.PrimaryKeyConstraint('id', name=op.f('pk_users')),
    sa.UniqueConstraint('email', name=op.f('uq_users_email'))
    )
    op.create_table('products',
    sa.Column('id', UUIDColumn(length=36), nullable=False), # Changed: directly use UUIDColumn
    sa.Column('name', sa.String(length=255), nullable=False),
    sa.Column('brand_id', UUIDColumn(length=36), nullable=False), # Changed: directly use UUIDColumn
    sa.Column('price', sa.DECIMAL(precision=10, scale=2), nullable=False),
    sa.Column('description', sa.Text(), nullable=True),
    sa.Column('image_url', sa.String(length=255), nullable=True),
    sa.Column('material', sa.String(length=100), nullable=True),
    sa.Column('category', sa.String(length=100), nullable=True),
    sa.Column('stock', sa.Integer(), nullable=True),
    sa.Column('sizes', postgresql.ARRAY(sa.String(length=10)), nullable=True),
    sa.Column('colors', postgresql.ARRAY(sa.String(length=50)), nullable=True),
    sa.Column('created_at', sa.DateTime(timezone=True), server_default=sa.text('now()'), nullable=True),
    sa.Column('updated_at', sa.DateTime(timezone=True), nullable=True),
    sa.ForeignKeyConstraint(['brand_id'], ['brands.id'], name=op.f('fk_products_brand_id_brands')),
    sa.PrimaryKeyConstraint('id', name=op.f('pk_products'))
    )
    op.create_table('favorites',
    sa.Column('user_id', UUIDColumn(length=36), nullable=False), # Changed: directly use UUIDColumn
    sa.Column('product_id', UUIDColumn(length=36), nullable=False), # Changed: directly use UUIDColumn
    sa.Column('created_at', sa.DateTime(timezone=True), server_default=sa.text('now()'), nullable=True),
    sa.ForeignKeyConstraint(['product_id'], ['products.id'], name=op.f('fk_favorites_product_id_products')),
    sa.ForeignKeyConstraint(['user_id'], ['users.id'], name=op.f('fk_favorites_user_id_users')),
    sa.PrimaryKeyConstraint('user_id', 'product_id', name=op.f('pk_favorites'))
    )
    op.create_table('transactions',
    sa.Column('id', UUIDColumn(length=36), nullable=False), # Changed: directly use UUIDColumn
    sa.Column('user_id', UUIDColumn(length=36), nullable=True), # Changed: directly use UUIDColumn
    sa.Column('product_id', UUIDColumn(length=36), nullable=False), # Changed: directly use UUIDColumn
    sa.Column('customer_name', sa.String(length=255), nullable=False),
    sa.Column('shipping_address', sa.Text(), nullable=False),
    sa.Column('payment_method', sa.String(length=50), nullable=False),
    sa.Column('transaction_status', sa.String(length=50), nullable=False),
    sa.Column('purchased_size', sa.String(length=10), nullable=False),
    sa.Column('purchased_color', sa.String(length=50), nullable=False),
    sa.Column('transaction_date', sa.DateTime(timezone=True), server_default=sa.text('now()'), nullable=True),
    sa.Column('updated_at', sa.DateTime(timezone=True), nullable=True),
    sa.ForeignKeyConstraint(['product_id'], ['products.id'], name=op.f('fk_transactions_product_id_products')),
    sa.ForeignKeyConstraint(['user_id'], ['users.id'], name=op.f('fk_transactions_user_id_users')),
    sa.PrimaryKeyConstraint('id', name=op.f('pk_transactions'))
    )
    # ### end Alembic commands ###


def downgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_table('transactions')
    op.drop_table('favorites')
    op.drop_table('products')
    op.drop_table('users')
    op.drop_table('inspirations')
    op.drop_table('brands')
    # ### end Alembic commands ###
```

## File: `wearspace_app\alembic\versions\README.txt`

```
Placeholder for alembic versions
```

## File: `wearspace_app\models\brand.py`

```
# your_project_name/models/brand.py
import uuid
from sqlalchemy import Column, DateTime, String
from sqlalchemy.sql import func
from sqlalchemy.orm import relationship
from .meta import Base, UUIDColumn

class Brand(Base):
    __tablename__ = 'brands'
    id = Column(UUIDColumn, primary_key=True, default=uuid.uuid4)
    name = Column(String(255), unique=True, nullable=False)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())

    products = relationship('Product', back_populates='brand', lazy=True)
```

## File: `wearspace_app\models\favorite.py`

```
# your_project_name/models/favorite.py
import uuid
from sqlalchemy import Column, DateTime, ForeignKey
from sqlalchemy.sql import func
from sqlalchemy.orm import relationship
from .meta import Base, UUIDColumn # Import UUIDColumn

class Favorite(Base):
    __tablename__ = 'favorites'
    user_id = Column(UUIDColumn, ForeignKey('users.id'), primary_key=True)
    product_id = Column(UUIDColumn, ForeignKey('products.id'), primary_key=True)
    created_at = Column(DateTime(timezone=True), server_default=func.now())

    user = relationship('User', back_populates='favorites')
    product = relationship('Product', back_populates='favorites')
```

## File: `wearspace_app\models\inspiration.py`

```
# your_project_name/models/inspiration.py
import uuid
from sqlalchemy import Column, DateTime, Text, String
from sqlalchemy.sql import func
from .meta import Base, UUIDColumn

class Inspiration(Base):
    __tablename__ = 'inspirations'
    id = Column(UUIDColumn, primary_key=True, default=uuid.uuid4)
    title = Column(String(255), nullable=False)
    description = Column(Text)
    image_url = Column(String(255))
    tag = Column(String(100))
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())
```

## File: `wearspace_app\models\meta.py`

```
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.schema import MetaData
from sqlalchemy.types import TypeDecorator, CHAR
import uuid

# Recommended naming convention used by Alembic, as various different database
# providers will autogenerate vastly different names making migrations more
# difficult. See: http://alembic.zzzcomputing.com/en/latest/naming.html
NAMING_CONVENTION = {
    "ix": "ix_%(column_0_label)s",
    "uq": "uq_%(table_name)s_%(column_0_name)s",
    "ck": "ck_%(table_name)s_%(constraint_name)s",
    "fk": "fk_%(table_name)s_%(column_0_name)s_%(referred_table_name)s",
    "pk": "pk_%(table_name)s"
}

metadata = MetaData(naming_convention=NAMING_CONVENTION)
Base = declarative_base(metadata=metadata)

class UUIDColumn(TypeDecorator):
    """
    UUIDType for SQLAlchemy, stores UUIDs as CHAR(32) and converts them to/from uuid.UUID objects.
    """
    impl = CHAR(36) # UUID string format is 36 characters (e.g., 'xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx')
    cache_ok = True

    def process_bind_param(self, value, dialect):
        if value is None:
            return value
        return str(value) # Convert UUID object to string

    def process_result_value(self, value, dialect):
        if value is None:
            return value
        return uuid.UUID(value) # Convert string to UUID object

```

## File: `wearspace_app\models\product.py`

```
# your_project_name/models/product.py
import uuid
from sqlalchemy import Column, DateTime, Text, Integer, String, DECIMAL, ForeignKey
from sqlalchemy.dialects.postgresql import ARRAY
from sqlalchemy.sql import func
from sqlalchemy.orm import relationship
from .meta import Base, UUIDColumn # Import UUIDColumn

class Product(Base):
    __tablename__ = 'products'
    id = Column(UUIDColumn, primary_key=True, default=uuid.uuid4)
    name = Column(String(255), nullable=False)
    brand_id = Column(UUIDColumn, ForeignKey('brands.id'), nullable=False)
    price = Column(DECIMAL(10, 2), nullable=False)
    description = Column(Text)
    image_url = Column(String(255))
    material = Column(String(100))
    category = Column(String(100))
    stock = Column(Integer, default=0)
    sizes = Column(ARRAY(String(10)))
    colors = Column(ARRAY(String(50)))
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())

    brand = relationship('Brand', back_populates='products')
    transactions = relationship('Transaction', back_populates='product', lazy=True)
    favorites = relationship('Favorite', back_populates='product', lazy=True)
```

## File: `wearspace_app\models\transaction.py`

```
# your_project_name/models/transaction.py
import uuid
from sqlalchemy import Column, DateTime, Text, Integer, String, DECIMAL, ForeignKey
from sqlalchemy.sql import func
from sqlalchemy.orm import relationship
from .meta import Base, UUIDColumn # Import UUIDColumn

class Transaction(Base):
    __tablename__ = 'transactions'
    id = Column(UUIDColumn, primary_key=True, default=uuid.uuid4)
    user_id = Column(UUIDColumn, ForeignKey('users.id'))
    product_id = Column(UUIDColumn, ForeignKey('products.id'), nullable=False)
    customer_name = Column(String(255), nullable=False)
    shipping_address = Column(Text, nullable=False)
    payment_method = Column(String(50), nullable=False)
    transaction_status = Column(String(50), nullable=False, default='Menunggu Pembayaran')
    purchased_size = Column(String(10), nullable=False)
    purchased_color = Column(String(50), nullable=False)
    transaction_date = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())

    user = relationship('User', back_populates='transactions')
    product = relationship('Product', back_populates='transactions')
```

## File: `wearspace_app\models\user.py`

```
# your_project_name/models/user.py
import uuid
from sqlalchemy import Column, DateTime, Text, String
from sqlalchemy.sql import func
from sqlalchemy.orm import relationship
from .meta import Base, UUIDColumn
from bcrypt import hashpw, gensalt, checkpw

class User(Base):
    __tablename__ = 'users'
    id = Column(UUIDColumn, primary_key=True, default=uuid.uuid4)
    email = Column(String(255), unique=True, nullable=False)
    hashed_password = Column(String(255), nullable=False)
    phone = Column(String(20))
    address = Column(Text)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())

    transactions = relationship('Transaction', back_populates='user', lazy=True)
    favorites = relationship('Favorite', back_populates='user', lazy=True)

    def set_password(self, password):
        self.hashed_password = hashpw(password.encode('utf-8'), gensalt()).decode('utf-8')

    def check_password(self, password):
        return checkpw(password.encode('utf-8'), self.hashed_password.encode('utf-8'))
```

## File: `wearspace_app\models\__init__.py`

```
from sqlalchemy import engine_from_config
from sqlalchemy.orm import sessionmaker
from sqlalchemy.orm import configure_mappers
import zope.sqlalchemy

# import or define all models here to ensure they are attached to the
# Base.metadata prior to any initialization routines
from .user import User
from .transaction import Transaction
from .brand import Brand
from .product import Product
from .favorite import Favorite
from .inspiration import Inspiration

from .meta import Base, UUIDColumn  # Import Base and UUIDColumn

# run configure_mappers after defining all of the models to ensure
# all relationships can be setup
configure_mappers()


def get_engine(settings, prefix='sqlalchemy.'):
    return engine_from_config(settings, prefix)


def get_session_factory(engine):
    factory = sessionmaker()
    factory.configure(bind=engine)
    return factory


def get_tm_session(session_factory, transaction_manager):
    """
    Get a ``sqlalchemy.orm.Session`` instance backed by a transaction.

    This function will hook the session to the transaction manager which
    will take care of committing any changes.

    - When using pyramid_tm it will automatically be committed or aborted
      depending on whether an exception is raised.

    - When using scripts you should wrap the session in a manager yourself.
      For example::

          import transaction

          engine = get_engine(settings)
          session_factory = get_session_factory(engine)
          with transaction.manager:
              dbsession = get_tm_session(session_factory, transaction.manager)

    """
    dbsession = session_factory()
    zope.sqlalchemy.register(
        dbsession, transaction_manager=transaction_manager)
    return dbsession


def includeme(config):
    """
    Initialize the model for a Pyramid app.

    Activate this setup using ``config.include('wearspace_app.models')``.

    """
    settings = config.get_settings()
    settings['tm.manager_hook'] = 'pyramid_tm.explicit_manager'

    # use pyramid_tm to hook the transaction lifecycle to the request
    config.include('pyramid_tm')

    # use pyramid_retry to retry a request when transient exceptions occur
    config.include('pyramid_retry')

    session_factory = get_session_factory(get_engine(settings))
    config.registry['dbsession_factory'] = session_factory

    # make request.dbsession available for use in Pyramid
    config.add_request_method(
        # r.tm is the transaction manager used by pyramid_tm
        lambda r: get_tm_session(session_factory, r.tm),
        'dbsession',
        reify=True
    )

```

## File: `wearspace_app\scripts\initialize_db.py`

```
import argparse
import sys
import uuid
from datetime import datetime

from pyramid.paster import bootstrap, setup_logging
from sqlalchemy.exc import OperationalError
import transaction # Import transaction explicitly if you want to control it manually outside Pyramid's tm

from ..models import (
    User,
    Brand,
    Product,
    Transaction,
    Favorite,
    Inspiration,
)

def setup_models(dbsession):
    """
    Add sample data to the database for Wearspace App.
    """
    print("🚀 Initializing Wearspace App database with sample data...")

    # Generate fresh, valid UUIDs for all sample data
    user_admin_id = uuid.uuid4()
    user_customer_id = uuid.uuid4()
    brand_nike_id = uuid.uuid4()
    brand_adidas_id = uuid.uuid4()
    product_shoe_id = uuid.uuid4()
    product_tshirt_id = uuid.uuid4()
    transaction_1_id = uuid.uuid4()
    transaction_2_id = uuid.uuid4()
    inspiration_1_id = uuid.uuid4()
    inspiration_2_id = uuid.uuid4()

    # --- Sample Users ---
    user_admin = User(
        id=user_admin_id,
        email="admin@wearspace.com",
        phone="081234567890",
        address="Jl. Admin No. 1, Jakarta"
    )
    user_admin.set_password("adminpass")
    dbsession.add(user_admin)

    user_customer = User(
        id=user_customer_id,
        email="customer@wearspace.com",
        phone="087654321000",
        address="Jl. Pelanggan No. 5, Bandung"
    )
    user_customer.set_password("customerpass")
    dbsession.add(user_customer)

    # --- Sample Brands ---
    brand_nike = Brand(
        id=brand_nike_id,
        name="Nike"
    )
    dbsession.add(brand_nike)

    brand_adidas = Brand(
        id=brand_adidas_id,
        name="Adidas"
    )
    dbsession.add(brand_adidas)

    # --- Sample Products ---
    product_shoe = Product(
        id=product_shoe_id,
        name="Nike Air Max 270",
        brand_id=brand_nike_id,
        price=150.00,
        description="Comfortable and stylish running shoes.",
        image_url="https://example.com/nike_airmax.jpg",
        material="Mesh, Rubber",
        category="Footwear",
        stock=50,
        sizes=['US 7', 'US 8', 'US 9', 'US 10'],
        colors=['Black', 'White', 'Red']
    )
    dbsession.add(product_shoe)

    product_tshirt = Product(
        id=product_tshirt_id,
        name="Adidas Trefoil T-Shirt",
        brand_id=brand_adidas_id,
        price=30.00,
        description="Classic cotton t-shirt with Adidas logo.",
        image_url="https://example.com/adidas_tshirt.jpg",
        material="Cotton",
        category="Apparel",
        stock=100,
        sizes=['S', 'M', 'L', 'XL'],
        colors=['Blue', 'Black']
    )
    dbsession.add(product_tshirt)

    # --- Sample Transactions ---
    transaction_1 = Transaction(
        id=transaction_1_id,
        user_id=user_customer_id,
        product_id=product_shoe_id,
        customer_name="John Doe",
        shipping_address="123 Main St, Anytown, USA",
        payment_method="Credit Card",
        transaction_status="Berhasil",
        purchased_size="US 9",
        purchased_color="Black",
        transaction_date=datetime(2025, 5, 20, 10, 30, 0)
    )
    dbsession.add(transaction_1)

    transaction_2 = Transaction(
        id=transaction_2_id,
        user_id=None, # Contoh transaksi tanpa user terdaftar (guest checkout)
        product_id=product_tshirt_id,
        customer_name="Jane Smith",
        shipping_address="456 Oak Ave, Othercity, USA",
        payment_method="PayPal",
        transaction_status="Menunggu Pembayaran",
        purchased_size="M",
        purchased_color="Blue",
        transaction_date=datetime(2025, 5, 25, 14, 0, 0)
    )
    dbsession.add(transaction_2)

    # --- Sample Favorites ---
    favorite_1 = Favorite(
        user_id=user_customer_id,
        product_id=product_shoe_id,
        created_at=datetime(2025, 5, 18, 9, 0, 0)
    )
    dbsession.add(favorite_1)

    # --- Sample Inspirations ---
    inspiration_1 = Inspiration(
        id=inspiration_1_id,
        title="Summer Style Guide",
        description="Latest trends for summer fashion.",
        image_url="https://example.com/summer_style.jpg",
        tag="Summer, Fashion, Trends",
        created_at=datetime(2025, 4, 1, 10, 0, 0)
    )
    dbsession.add(inspiration_1)

    inspiration_2 = Inspiration(
        id=inspiration_2_id,
        title="Sportswear Essentials",
        description="Must-have items for your workout.",
        image_url="https://example.com/sportswear.jpg",
        tag="Sport, Fitness, Essentials",
        created_at=datetime(2025, 4, 15, 11, 0, 0)
    )
    dbsession.add(inspiration_2)


def parse_args(argv):
    parser = argparse.ArgumentParser()
    parser.add_argument(
        'config_uri',
        help='Configuration file, e.g., development.ini',
    )
    return parser.parse_args(argv[1:])


def main(argv=sys.argv):
    args = parse_args(argv)
    setup_logging(args.config_uri)

    env = None # Initialize env to None outside try block
    try:
        env = bootstrap(args.config_uri)
        with env['request'].tm: # This context manager automatically handles commit/rollback
            dbsession = env['request'].dbsession
            setup_models(dbsession)
            print("✅ Sample data for Wearspace App inserted successfully.")
    except OperationalError as err:
        print("❌ OperationalError:", err)
        print('''
Database connection failed. The problem might be caused by one of the following:

1. You may need to initialize your database tables with `alembic upgrade head`.
   Make sure you have run Alembic migrations.

2. Your database server may not be running or misconfigured. Check that the
   database server referred to by the "sqlalchemy.url" setting in
   your "development.ini" file is running and accessible.
        ''')
        # pyramid_tm will automatically abort the transaction if an OperationalError occurs
        # so explicit abort() is not strictly needed here for this error type.
    except Exception as e:
        print(f"An unexpected error occurred: {e}")
        # For general exceptions, `with env['request'].tm:` should still handle rollback.
        # Re-raise the exception to see its full traceback if it's not OperationalError
        raise
```

## File: `wearspace_app\scripts\__init__.py`

```
# package

```

## File: `wearspace_app\views\api.py`

```
import uuid
from pyramid.view import view_config
from pyramid.response import Response
from webob.exc import HTTPNotFound, HTTPBadRequest, HTTPInternalServerError, HTTPUnauthorized, HTTPConflict
from sqlalchemy.exc import IntegrityError
from sqlalchemy import func
from ..models import (
    User, Brand, Product, Transaction, Favorite, Inspiration
)
from ..models.meta import UUIDColumn # Pastikan ini benar
from pyramid.security import remember, forget # Hapus authenticated_userid dari sini
from datetime import datetime
from decimal import Decimal

# Helper: validasi field kosong
def require_fields(data, required_fields):
    missing = [f for f in required_fields if not data.get(f)]
    if missing:
        # Langsung raise exception HTTP
        raise HTTPBadRequest(json={'error': f'Missing fields: {", ".join(missing)}'})

# Helper: Serialisasi objek
def serialize_object(obj):
    if not obj:
        return None
    data = {c.name: getattr(obj, c.name) for c in obj.__table__.columns}
    for key, value in data.items():
        if isinstance(value, uuid.UUID):
            data[key] = str(value)
        elif isinstance(value, datetime):
            if value:
                data[key] = value.isoformat()
        elif isinstance(value, Decimal):
            data[key] = float(value)
    if 'hashed_password' in data: # Hapus hashed_password untuk keamanan
        del data['hashed_password']
    return data

# --- Authentication and User Management ---

@view_config(route_name='register', request_method='POST', renderer='json')
def register_user(request):
    data = request.json_body
    
    try:
        require_fields(data, ['email', 'password'])
    except HTTPBadRequest as e: # Tangkap exception yang di-raise helper
        raise e

    email = data['email']
    password = data['password']

    try:
        existing_user = request.dbsession.query(User).filter_by(email=email).first()
        if existing_user:
            raise HTTPConflict(json={'error': 'User with this email already exists.'}) # Gunakan HTTPConflict

        user = User(email=email)
        user.set_password(password)
        user.phone = data.get('phone')
        user.address = data.get('address')
        user.username = data.get('username') # Pastikan username juga ditambahkan jika ada di model User

        request.dbsession.add(user)
        request.dbsession.flush()
        return Response(json={'message': 'User registered successfully!', 'user': serialize_object(user)}, status=201)
    except IntegrityError:
        request.dbsession.rollback()
        # Jika ada unique constraint lain selain email, bisa juga tertangkap di sini
        raise HTTPBadRequest(json={'error': 'User with this email already exists or other integrity error.'})
    except HTTPConflict as e: # Tangkap HTTPConflict yang kita raise
        raise e
    except Exception as e:
        request.dbsession.rollback()
        raise HTTPInternalServerError(f'Failed to register user: {e}')

@view_config(route_name='login', request_method='POST', renderer='json')
def login_user(request):
    data = request.json_body

    try:
        require_fields(data, ['email', 'password'])
    except HTTPBadRequest as e:
        raise e

    email = data['email']
    password = data['password']

    user = request.dbsession.query(User).filter_by(email=email).first()
    if not user or not user.check_password(password):
        raise HTTPUnauthorized(json={'error': 'Invalid credentials.'})

    # Membuat cookie autentikasi AuthTkt
    # user.id harus berupa string karena itu yang diharapkan oleh AuthTktAuthenticationPolicy
    headers = remember(request, str(user.id))

    response = Response(json={
        'message': 'Login successful!',
        'user': serialize_object(user),
        # Opsional: untuk verifikasi di sisi klien bahwa user terautentikasi
        'authenticated_userid': request.authenticated_userid # Gunakan request.authenticated_userid
    })
    response.headers.extend(headers) # Menambahkan header Set-Cookie ke response
    return response

@view_config(route_name='logout', request_method='POST', renderer='json')
def logout_user(request):
    # Menghapus cookie autentikasi AuthTkt
    headers = forget(request)
    response = Response(json={'message': 'Logged out successfully.'})
    response.headers.extend(headers) # Menambahkan header untuk menghapus cookie ke response
    return response

@view_config(route_name='users', request_method='GET', renderer='json')
def get_users(request):
    users = request.dbsession.query(User).all()
    return [serialize_object(user) for user in users]

@view_config(route_name='user_by_id', request_method='GET', renderer='json')
def get_user(request):
    user_id = request.matchdict['id']
    try:
        user = request.dbsession.query(User).get(uuid.UUID(user_id))
    except ValueError:
        raise HTTPBadRequest(json={'error': 'Invalid UUID format for user ID.'})
    if not user:
        raise HTTPNotFound(json={'error': 'User not found.'})
    return serialize_object(user)

@view_config(route_name='user_by_id', request_method='PUT', renderer='json')
def update_user(request):
    user_id = request.matchdict['id']
    data = request.json_body
    try:
        user = request.dbsession.query(User).get(uuid.UUID(user_id))
    except ValueError:
        raise HTTPBadRequest(json={'error': 'Invalid UUID format for user ID.'})
    if not user:
        raise HTTPNotFound(json={'error': 'User not found.'})

    try:
        if 'password' in data:
            user.set_password(data['password'])
            del data['password'] # Hapus password dari data agar tidak di-setattr lagi

        for key, value in data.items():
            if hasattr(user, key):
                setattr(user, key, value)
        request.dbsession.flush()
        return serialize_object(user)
    except IntegrityError:
        request.dbsession.rollback()
        raise HTTPConflict(json={'error': 'Email already in use or other integrity error.'}) # Gunakan HTTPConflict
    except Exception as e:
        request.dbsession.rollback()
        raise HTTPInternalServerError(f'Failed to update user: {e}')

@view_config(route_name='user_by_id', request_method='DELETE', renderer='json')
def delete_user(request):
    user_id = request.matchdict['id']
    try:
        user = request.dbsession.query(User).get(uuid.UUID(user_id))
    except ValueError:
        raise HTTPBadRequest(json={'error': 'Invalid UUID format for user ID.'})
    if not user:
        raise HTTPNotFound(json={'error': 'User not found.'})

    request.dbsession.delete(user)
    return Response(json={'message': 'User deleted successfully'}, status=204)

# --- Brand Management ---

@view_config(route_name='brands', request_method='GET', renderer='json')
def get_brands(request):
    brands = request.dbsession.query(Brand).all()
    return [serialize_object(brand) for brand in brands]

@view_config(route_name='brands', request_method='POST', renderer='json')
def create_brand(request):
    data = request.json_body
    try:
        require_fields(data, ['name'])
    except HTTPBadRequest as e:
        raise e

    try:
        brand = Brand(name=data['name'])
        request.dbsession.add(brand)
        request.dbsession.flush()
        return Response(json=serialize_object(brand), status=201)
    except IntegrityError:
        request.dbsession.rollback()
        raise HTTPConflict(json={'error': 'Brand with this name already exists.'}) # Gunakan HTTPConflict
    except Exception as e:
        request.dbsession.rollback()
        raise HTTPInternalServerError(f'Failed to create brand: {e}')

@view_config(route_name='brand_by_id', request_method='PUT', renderer='json')
def update_brand(request):
    brand_id = request.matchdict['id']
    data = request.json_body
    try:
        brand = request.dbsession.query(Brand).get(uuid.UUID(brand_id))
    except ValueError:
        raise HTTPBadRequest(json={'error': 'Invalid UUID format for brand ID.'})
    if not brand:
        raise HTTPNotFound(json={'error': 'Brand not found.'})

    try:
        if 'name' in data:
            brand.name = data['name']
        request.dbsession.flush()
        return serialize_object(brand)
    except IntegrityError:
        request.dbsession.rollback()
        raise HTTPConflict(json={'error': 'Brand name already exists.'}) # Gunakan HTTPConflict
    except Exception as e:
        request.dbsession.rollback()
        raise HTTPInternalServerError(f'Failed to update brand: {e}')

@view_config(route_name='brand_by_id', request_method='DELETE', renderer='json')
def delete_brand(request):
    brand_id = request.matchdict['id']
    try:
        brand = request.dbsession.query(Brand).get(uuid.UUID(brand_id))
    except ValueError:
        raise HTTPBadRequest(json={'error': 'Invalid UUID format for brand ID.'})
    if not brand:
        raise HTTPNotFound(json={'error': 'Brand not found.'})

    request.dbsession.delete(brand)
    return Response(json={'message': 'Brand deleted successfully'}, status=204)

# --- Product Management ---

@view_config(route_name='products', request_method='GET', renderer='json')
def get_products(request):
    products = request.dbsession.query(Product).all()
    return [serialize_object(p) for p in products]

@view_config(route_name='products', request_method='POST', renderer='json')
def create_product(request):
    data = request.json_body
    required_fields = ['name', 'brand_id', 'price', 'stock', 'sizes', 'colors']
    
    try:
        require_fields(data, required_fields)
    except HTTPBadRequest as e:
        raise e

    try:
        brand_id_uuid = uuid.UUID(data['brand_id'])
        brand = request.dbsession.query(Brand).get(brand_id_uuid)
        if not brand:
            raise HTTPBadRequest(json={'error': 'Brand not found for the given brand_id.'})

        product = Product(
            name=data['name'],
            brand_id=brand_id_uuid,
            price=data['price'],
            stock=data['stock'],
            sizes=data['sizes'],
            colors=data['colors'],
            description=data.get('description'),
            image_url=data.get('image_url'),
            material=data.get('material'),
            category=data.get('category')
        )
        request.dbsession.add(product)
        request.dbsession.flush()
        return Response(json=serialize_object(product), status=201)
    except ValueError:
        raise HTTPBadRequest(json={'error': 'Invalid UUID format for brand ID.'})
    except Exception as e:
        request.dbsession.rollback()
        raise HTTPInternalServerError(f'Failed to create product: {e}')

@view_config(route_name='product_by_id', request_method='GET', renderer='json')
def get_product(request):
    product_id = request.matchdict['id']
    try:
        product = request.dbsession.query(Product).get(uuid.UUID(product_id))
    except ValueError:
        raise HTTPBadRequest(json={'error': 'Invalid UUID format for product ID.'})
    if not product:
        raise HTTPNotFound(json={'error': 'Product not found.'})
    return serialize_object(product)

@view_config(route_name='product_by_id', request_method='PUT', renderer='json')
def update_product(request):
    product_id = request.matchdict['id']
    data = request.json_body
    try:
        product = request.dbsession.query(Product).get(uuid.UUID(product_id))
    except ValueError:
        raise HTTPBadRequest(json={'error': 'Invalid UUID format for product ID.'})
    if not product:
        raise HTTPNotFound(json={'error': 'Product not found.'})

    try:
        if 'brand_id' in data:
            brand_id_uuid = uuid.UUID(data['brand_id'])
            brand = request.dbsession.query(Brand).get(brand_id_uuid)
            if not brand:
                raise HTTPBadRequest(json={'error': 'Brand not found for the given brand_id.'})
            product.brand_id = brand_id_uuid

        for key, value in data.items():
            if key not in ['brand_id'] and hasattr(product, key):
                setattr(product, key, value)

        request.dbsession.flush()
        return serialize_object(product)
    except ValueError:
        raise HTTPBadRequest(json={'error': 'Invalid UUID format provided.'})
    except Exception as e:
        request.dbsession.rollback()
        raise HTTPInternalServerError(f'Failed to update product: {e}')

@view_config(route_name='product_by_id', request_method='DELETE', renderer='json')
def delete_product(request):
    product_id = request.matchdict['id']
    try:
        product = request.dbsession.query(Product).get(uuid.UUID(product_id))
    except ValueError:
        raise HTTPBadRequest(json={'error': 'Invalid UUID format for product ID.'})
    if not product:
        raise HTTPNotFound(json={'error': 'Product not found.'})

    request.dbsession.delete(product)
    return Response(json={'message': 'Product deleted successfully'}, status=204)

# --- Transaction Management ---

@view_config(route_name='transactions', request_method='GET', renderer='json')
def get_transactions(request):
    transactions = request.dbsession.query(Transaction).all()
    serialized_transactions = []
    for t in transactions:
        t_data = serialize_object(t)
        if t.product:
            t_data['product'] = serialize_object(t.product)
        if t.user:
            t_data['user'] = serialize_object(t.user)
        serialized_transactions.append(t_data)
    return serialized_transactions

@view_config(route_name='transactions', request_method='POST', renderer='json')
def create_transaction(request):
    data = request.json_body
    required_fields = ['product_id', 'customer_name', 'shipping_address',
                       'payment_method', 'purchased_size', 'purchased_color']
    
    try:
        require_fields(data, required_fields)
    except HTTPBadRequest as e:
        raise e

    try:
        product_id_uuid = uuid.UUID(data['product_id'])
        product = request.dbsession.query(Product).get(product_id_uuid)
        if not product:
            raise HTTPBadRequest(json={'error': 'Product not found.'})

        if product.stock <= 0:
            raise HTTPBadRequest(json={'error': 'Product out of stock.'})

        product.stock -= 1

        user_id = None
        # Gunakan request.authenticated_userid untuk mendapatkan ID pengguna yang sedang login
        if request.authenticated_userid:
            user_id = uuid.UUID(request.authenticated_userid)

        transaction = Transaction(
            user_id=user_id, # user_id bisa None jika tidak ada yang login
            product_id=product_id_uuid,
            customer_name=data['customer_name'],
            shipping_address=data['shipping_address'],
            payment_method=data['payment_method'],
            purchased_size=data['purchased_size'],
            purchased_color=data['purchased_color'],
            transaction_status='Menunggu Pembayaran'
        )
        request.dbsession.add(transaction)
        request.dbsession.flush()

        return Response(json=serialize_object(transaction), status=201)
    except ValueError:
        raise HTTPBadRequest(json={'error': 'Invalid UUID format.'})
    except Exception as e:
        request.dbsession.rollback()
        raise HTTPInternalServerError(f'Failed to create transaction: {e}')

@view_config(route_name='transaction_by_id', request_method='GET', renderer='json')
def get_transaction(request):
    transaction_id = request.matchdict['id']
    try:
        transaction = request.dbsession.query(Transaction).get(uuid.UUID(transaction_id))
    except ValueError:
        raise HTTPBadRequest(json={'error': 'Invalid UUID format for transaction ID.'})
    if not transaction:
        raise HTTPNotFound(json={'error': 'Transaction not found.'})

    t_data = serialize_object(transaction)
    if transaction.product:
        t_data['product'] = serialize_object(transaction.product)
    if transaction.user:
        t_data['user'] = serialize_object(transaction.user)
    return t_data

@view_config(route_name='transaction_by_id', request_method='PUT', renderer='json')
def update_transaction_status(request):
    transaction_id = request.matchdict['id']
    data = request.json_body
    if 'transaction_status' not in data:
        raise HTTPBadRequest(json={'error': 'Transaction status is required for update.'})

    try:
        transaction = request.dbsession.query(Transaction).get(uuid.UUID(transaction_id))
    except ValueError:
        raise HTTPBadRequest(json={'error': 'Invalid UUID format for transaction ID.'})
    if not transaction:
        raise HTTPNotFound(json={'error': 'Transaction not found.'})

    valid_statuses = ['Menunggu Pembayaran', 'Berhasil', 'Dibatalkan']
    if data['transaction_status'] not in valid_statuses:
        raise HTTPBadRequest(json={'error': f"Invalid status. Must be one of: {', '.join(valid_statuses)}"})

    try:
        transaction.transaction_status = data['transaction_status']
        request.dbsession.flush()
        return serialize_object(transaction)
    except Exception as e:
        request.dbsession.rollback()
        raise HTTPInternalServerError(f'Failed to update transaction status: {e}')

@view_config(route_name='transaction_by_id', request_method='DELETE', renderer='json')
def delete_transaction(request):
    transaction_id = request.matchdict['id']
    try:
        transaction = request.dbsession.query(Transaction).get(uuid.UUID(transaction_id))
    except ValueError:
        raise HTTPBadRequest(json={'error': 'Invalid UUID format for transaction ID.'})
    if not transaction:
        raise HTTPNotFound(json={'error': 'Transaction not found.'})

    request.dbsession.delete(transaction)
    return Response(json={'message': 'Transaction deleted successfully'}, status=204)

# --- Favorite Management ---

@view_config(route_name='favorites', request_method='GET', renderer='json')
def get_favorites(request):
    # Mengambil ID pengguna yang sedang login
    user_id = request.authenticated_userid # Langsung pakai request.authenticated_userid
    if not user_id:
        raise HTTPUnauthorized(json={'error': 'Authentication required to view favorites.'})

    try:
        user_uuid = uuid.UUID(user_id)
    except ValueError:
        raise HTTPBadRequest(json={'error': 'Invalid UUID format for user ID in session.'})

    favorites = request.dbsession.query(Favorite).filter(Favorite.user_id == user_uuid).all()
    favorite_products = []
    for fav in favorites:
        if fav.product:
            favorite_products.append(serialize_object(fav.product))
    return favorite_products

@view_config(route_name='favorites', request_method='POST', renderer='json')
def add_favorite(request):
    # Mengambil ID pengguna yang sedang login
    user_id = request.authenticated_userid # Langsung pakai request.authenticated_userid
    if not user_id:
        raise HTTPUnauthorized(json={'error': 'Authentication required to add favorite.'})

    data = request.json_body
    try:
        require_fields(data, ['product_id'])
    except HTTPBadRequest as e:
        raise e

    try:
        user_uuid = uuid.UUID(user_id)
        product_uuid = uuid.UUID(data['product_id'])

        user = request.dbsession.query(User).get(user_uuid)
        product = request.dbsession.query(Product).get(product_uuid)
        if not user or not product:
            raise HTTPNotFound(json={'error': 'User or Product not found.'})

        existing_favorite = request.dbsession.query(Favorite).filter_by(
            user_id=user_uuid, product_id=product_uuid
        ).first()
        if existing_favorite:
            raise HTTPConflict(json={'error': 'Product already in favorites.'})

        favorite = Favorite(user_id=user_uuid, product_id=product_uuid)
        request.dbsession.add(favorite)
        request.dbsession.flush()
        return Response(json={'message': 'Product added to favorites'}, status=201)
    except ValueError:
        raise HTTPBadRequest(json={'error': 'Invalid UUID format.'})
    except IntegrityError:
        request.dbsession.rollback()
        # Jika ada unique constraint di database, ini akan terpicu
        raise HTTPConflict(json={'error': 'Product already in favorites (integrity constraint).'})
    except HTTPConflict as e: # Tangkap HTTPConflict yang kita raise
        raise e
    except Exception as e:
        request.dbsession.rollback()
        raise HTTPInternalServerError(f'Failed to add favorite: {e}')

@view_config(route_name='favorite_by_product_id', request_method='DELETE', renderer='json')
def remove_favorite(request):
    # Mengambil ID pengguna yang sedang login
    user_id = request.authenticated_userid # Langsung pakai request.authenticated_userid
    if not user_id:
        raise HTTPUnauthorized(json={'error': 'Authentication required to remove favorite.'})

    product_id = request.matchdict['product_id']
    try:
        user_uuid = uuid.UUID(user_id)
        product_uuid = uuid.UUID(product_id)
    except ValueError:
        raise HTTPBadRequest(json={'error': 'Invalid UUID format.'})

    favorite = request.dbsession.query(Favorite).filter_by(
        user_id=user_uuid, product_id=product_uuid
    ).first()
    if not favorite:
        raise HTTPNotFound(json={'error': 'Favorite not found.'})

    request.dbsession.delete(favorite)
    return Response(json={'message': 'Product removed from favorites'}, status=204)

# --- Inspiration Management ---

@view_config(route_name='inspirations', request_method='GET', renderer='json')
def get_inspirations(request):
    tag = request.params.get('tag')
    query = request.dbsession.query(Inspiration)
    if tag:
        query = query.filter(Inspiration.tag.ilike(f'%{tag}%'))
    inspirations = query.all()
    return [serialize_object(inspo) for inspo in inspirations]

@view_config(route_name='inspirations', request_method='POST', renderer='json')
def create_inspiration(request):
    data = request.json_body
    required_fields = ['title', 'description', 'image_url', 'tag']
    
    try:
        require_fields(data, required_fields)
    except HTTPBadRequest as e:
        raise e

    try:
        inspiration = Inspiration(
            title=data['title'],
            description=data['description'],
            image_url=data['image_url'],
            tag=data['tag']
        )
        request.dbsession.add(inspiration)
        request.dbsession.flush()
        return Response(json=serialize_object(inspiration), status=201)
    except Exception as e:
        request.dbsession.rollback()
        raise HTTPInternalServerError(f'Failed to create inspiration: {e}')

@view_config(route_name='inspiration_by_id', request_method='GET', renderer='json')
def get_inspiration(request):
    inspiration_id = request.matchdict['id']
    try:
        inspiration = request.dbsession.query(Inspiration).get(uuid.UUID(inspiration_id))
    except ValueError:
        raise HTTPBadRequest(json={'error': 'Invalid UUID format for inspiration ID.'})
    if not inspiration:
        raise HTTPNotFound(json={'error': 'Inspiration not found.'})
    return serialize_object(inspiration)

@view_config(route_name='inspiration_by_id', request_method='PUT', renderer='json')
def update_inspiration(request):
    inspiration_id = request.matchdict['id']
    data = request.json_body
    try:
        inspiration = request.dbsession.query(Inspiration).get(uuid.UUID(inspiration_id))
    except ValueError:
        raise HTTPBadRequest(json={'error': 'Invalid UUID format for inspiration ID.'})
    if not inspiration:
        raise HTTPNotFound(json={'error': 'Inspiration not found.'})

    try:
        for key, value in data.items():
            if hasattr(inspiration, key):
                setattr(inspiration, key, value)
        request.dbsession.flush()
        return serialize_object(inspiration)
    except Exception as e:
        request.dbsession.rollback()
        raise HTTPInternalServerError(f'Failed to update inspiration: {e}')

@view_config(route_name='inspiration_by_id', request_method='DELETE', renderer='json')
def delete_inspiration(request):
    inspiration_id = request.matchdict['id']
    try:
        inspiration = request.dbsession.query(Inspiration).get(uuid.UUID(inspiration_id))
    except ValueError:
        raise HTTPBadRequest(json={'error': 'Invalid UUID format for inspiration ID.'})
    if not inspiration:
        raise HTTPNotFound(json={'error': 'Inspiration not found.'})

    request.dbsession.delete(inspiration)
    return Response(json={'message': 'Inspiration deleted successfully'}, status=204)
```

## File: `wearspace_app\views\default.py`

```
from pyramid.response import Response
from pyramid.view import view_config

@view_config(route_name='home')
def home_view(request):
    return Response('Wearspace API', content_type='text/plain')
```

## File: `wearspace_app\views\notfound.py`

```
from pyramid.view import notfound_view_config


@notfound_view_config(renderer='../templates/404.jinja2')
def notfound_view(request):
    request.response.status = 404
    return {}

```

## File: `wearspace_app\views\__init__.py`

```

```

## File: `wearspace_app\cors.py`

```
# In a file called tweens.py or in the main file
from pyramid.response import Response
from pyramid.httpexceptions import HTTPForbidden

def cors_tween_factory(handler, registry):
    def cors_tween(request):
        # Allow specific origin (not *)
        allowed_origin = 'http://localhost:5173'

        if request.method == 'OPTIONS':
            # Preflight response
            response = request.response
            response.headers['Access-Control-Allow-Origin'] = allowed_origin
            response.headers['Access-Control-Allow-Credentials'] = 'true'
            response.headers['Access-Control-Allow-Methods'] = 'GET, POST, PUT, DELETE, OPTIONS'
            response.headers['Access-Control-Allow-Headers'] = 'Content-Type, Authorization'
            response.headers['Access-Control-Max-Age'] = '3600'
            
            return response

        # Actual response
        response = handler(request)
        response.headers['Access-Control-Allow-Origin'] = allowed_origin
        response.headers['Access-Control-Allow-Credentials'] = 'true'
        response.headers['Access-Control-Allow-Methods'] = 'GET, POST, PUT, DELETE, OPTIONS'
        response.headers['Access-Control-Allow-Headers'] = 'Content-Type, Authorization'
        
        return response

    return cors_tween
```

## File: `wearspace_app\pshell.py`

```
from . import models

def setup(env):
    request = env['request']

    # start a transaction
    request.tm.begin()

    # inject some vars into the shell builtins
    env['tm'] = request.tm
    env['dbsession'] = request.dbsession
    env['models'] = models

```

## File: `wearspace_app\routes.py`

```
# wearspace_app/routes.py
def includeme(config):
    config.add_static_view('static', 'static', cache_max_age=3600)
    config.add_route('home', '/')

    # API Routes for Users
    config.add_route('users', '/api/users')
    config.add_route('user_by_id', '/api/users/{id}')

    # --- API Routes for Auth (TAMBAHKAN INI) ---
    config.add_route('register', '/api/auth/register')
    config.add_route('login', '/api/auth/login')
    config.add_route('logout', '/api/auth/logout')
    # --------------------------------------------

    # API Routes for Brands
    config.add_route('brands', '/api/brands')
    config.add_route('brand_by_id', '/api/brands/{id}')

    # API Routes for Products
    config.add_route('products', '/api/products')
    config.add_route('product_by_id', '/api/products/{id}')

    # API Routes for Transactions
    config.add_route('transactions', '/api/transactions')
    config.add_route('transaction_by_id', '/api/transactions/{id}')

    # API Routes for Favorites
    config.add_route('favorites', '/api/favorites')
    config.add_route('favorite_by_product_id', '/api/favorites/{product_id}')

    # API Routes for Inspirations
    config.add_route('inspirations', '/api/inspirations')
    config.add_route('inspiration_by_id', '/api/inspirations/{id}')
```

## File: `wearspace_app\tests.py`

```

```

## File: `wearspace_app\__init__.py`

```
from pyramid.config import Configurator
from pyramid.session import SignedCookieSessionFactory
from pyramid.authentication import AuthTktAuthenticationPolicy
from pyramid.authorization import ACLAuthorizationPolicy
from sqlalchemy import engine_from_config
from .models.meta import Base
from .models import User # Import User model untuk callback auth
from pyramid.renderers import JSON
from .cors import cors_tween_factory
import uuid # Diperlukan untuk get_user_principals

# Callback untuk AuthTktAuthenticationPolicy
def get_user_principals(userid, request):
    # userid adalah string user ID yang disimpan di ticket
    try:
        user_uuid = uuid.UUID(userid)
        user = request.dbsession.query(User).get(user_uuid)
        if user:
            # Mengembalikan list principals. Contoh: ['user:{user_id}', 'group:users']
            # Untuk kasus sederhana, kita hanya mengembalikan user ID sebagai principal
            return [f'user:{user.id}']
        return None
    except ValueError:
        return None # Handle jika userid bukan UUID yang valid

def main(global_config, **settings):
    """ This function returns a Pyramid WSGI application. """

    config = Configurator(settings=settings)

    # 1. Konfigurasi CORS (harus di awal)
    config.add_tween('.cors_tween_factory')
    config.add_renderer('json', JSON(indent=4))

    # 2. Konfigurasi Session Factory (AuthTkt policy membutuhkan ini)
    session_secret = settings.get('session.secret', 'a_default_session_secret_for_dev') # Ganti dengan secret kuat
    session_factory = SignedCookieSessionFactory(session_secret)
    config.set_session_factory(session_factory)

    # 3. Konfigurasi Authentication dan Authorization Policy
    auth_secret = settings.get('auth.secret', 'a_default_auth_secret_for_dev') # Ganti dengan secret kuat
    authn_policy = AuthTktAuthenticationPolicy(
        auth_secret,
        callback=get_user_principals,
        hashalg='sha512',
        cookie_name='wearspace_auth',
        # secure=True, # Aktifkan di produksi dengan HTTPS
        # httponly=True, # Pastikan ini True untuk keamanan cookie
        # wildcard_domain=False # Aktifkan jika aplikasi di subdomain berbeda
    )
    authz_policy = ACLAuthorizationPolicy()

    config.set_authentication_policy(authn_policy)
    config.set_authorization_policy(authz_policy)

    # 4. Include other Pyramid extensions/modules
    config.include('pyramid_jinja2')
    # `pyramid_sqlalchemy` harus di-include sebelum `.models`
    # karena `.models` mungkin bergantung pada konfigurasi SQLAlchemy dari `pyramid_sqlalchemy`
    config.include('pyramid_sqlalchemy') # Ini akan mengatur dbsession dan engine
    config.include('pyramid_tm')
    config.include('pyramid_retry')

    # 5. Include your application's models and routes
    config.include('.models') # Ini akan memanggil includeme dari wearspace_app/models/__init__.py
    config.include('.routes') # Ini akan memanggil includeme dari wearspace_app/routes.py

    # 6. Scan views and other declaratively configured components
    config.scan()

    return config.make_wsgi_app()
```

## File: `wearspace_app\alembic\env.py`

```
"""Pyramid bootstrap environment. """
from alembic import context
from pyramid.paster import get_appsettings, setup_logging
from sqlalchemy import engine_from_config

from wearspace_app.models.meta import Base

config = context.config

setup_logging(config.config_file_name)

settings = get_appsettings(config.config_file_name)
target_metadata = Base.metadata


def run_migrations_offline():
    """Run migrations in 'offline' mode.

    This configures the context with just a URL
    and not an Engine, though an Engine is acceptable
    here as well.  By skipping the Engine creation
    we don't even need a DBAPI to be available.

    Calls to context.execute() here emit the given string to the
    script output.

    """
    context.configure(url=settings['sqlalchemy.url'])
    with context.begin_transaction():
        context.run_migrations()


def run_migrations_online():
    """Run migrations in 'online' mode.

    In this scenario we need to create an Engine
    and associate a connection with the context.

    """
    engine = engine_from_config(settings, prefix='sqlalchemy.')

    connection = engine.connect()
    context.configure(
        connection=connection,
        target_metadata=target_metadata
    )

    try:
        with context.begin_transaction():
            context.run_migrations()
    finally:
        connection.close()


if context.is_offline_mode():
    run_migrations_offline()
else:
    run_migrations_online()

```

## File: `wearspace_app\alembic\script.py.mako`

```
"""${message}

Revision ID: ${up_revision}
Revises: ${down_revision | comma,n}
Create Date: ${create_date}

"""
from alembic import op
import sqlalchemy as sa
${imports if imports else ""}

# revision identifiers, used by Alembic.
revision = ${repr(up_revision)}
down_revision = ${repr(down_revision)}
branch_labels = ${repr(branch_labels)}
depends_on = ${repr(depends_on)}


def upgrade():
    ${upgrades if upgrades else "pass"}


def downgrade():
    ${downgrades if downgrades else "pass"}

```

## File: `wearspace_app\alembic\versions\20250527_294e4f48bbcd.py`

```
"""create wearspace tabel

Revision ID: 294e4f48bbcd
Revises:
Create Date: 2025-05-27 20:39:23.791326

"""
from alembic import op
import sqlalchemy as sa
from sqlalchemy.dialects import postgresql

# --- THIS IS THE CRUCIAL LINE YOU NEED TO ADD ---
from wearspace_app.models.meta import UUIDColumn
# -------------------------------------------------


# revision identifiers, used by Alembic.
revision = '294e4f48bbcd'
down_revision = None
branch_labels = None
depends_on = None


def upgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table('brands',
    sa.Column('id', UUIDColumn(length=36), nullable=False), # Changed: directly use UUIDColumn
    sa.Column('name', sa.String(length=255), nullable=False),
    sa.Column('created_at', sa.DateTime(timezone=True), server_default=sa.text('now()'), nullable=True),
    sa.Column('updated_at', sa.DateTime(timezone=True), nullable=True),
    sa.PrimaryKeyConstraint('id', name=op.f('pk_brands')),
    sa.UniqueConstraint('name', name=op.f('uq_brands_name'))
    )
    op.create_table('inspirations',
    sa.Column('id', UUIDColumn(length=36), nullable=False), # Changed: directly use UUIDColumn
    sa.Column('title', sa.String(length=255), nullable=False),
    sa.Column('description', sa.Text(), nullable=True),
    sa.Column('image_url', sa.String(length=255), nullable=True),
    sa.Column('tag', sa.String(length=100), nullable=True),
    sa.Column('created_at', sa.DateTime(timezone=True), server_default=sa.text('now()'), nullable=True),
    sa.Column('updated_at', sa.DateTime(timezone=True), nullable=True),
    sa.PrimaryKeyConstraint('id', name=op.f('pk_inspirations'))
    )
    op.create_table('users',
    sa.Column('id', UUIDColumn(length=36), nullable=False), # Changed: directly use UUIDColumn
    sa.Column('email', sa.String(length=255), nullable=False),
    sa.Column('hashed_password', sa.String(length=255), nullable=False),
    sa.Column('phone', sa.String(length=20), nullable=True),
    sa.Column('address', sa.Text(), nullable=True),
    sa.Column('created_at', sa.DateTime(timezone=True), server_default=sa.text('now()'), nullable=True),
    sa.Column('updated_at', sa.DateTime(timezone=True), nullable=True),
    sa.PrimaryKeyConstraint('id', name=op.f('pk_users')),
    sa.UniqueConstraint('email', name=op.f('uq_users_email'))
    )
    op.create_table('products',
    sa.Column('id', UUIDColumn(length=36), nullable=False), # Changed: directly use UUIDColumn
    sa.Column('name', sa.String(length=255), nullable=False),
    sa.Column('brand_id', UUIDColumn(length=36), nullable=False), # Changed: directly use UUIDColumn
    sa.Column('price', sa.DECIMAL(precision=10, scale=2), nullable=False),
    sa.Column('description', sa.Text(), nullable=True),
    sa.Column('image_url', sa.String(length=255), nullable=True),
    sa.Column('material', sa.String(length=100), nullable=True),
    sa.Column('category', sa.String(length=100), nullable=True),
    sa.Column('stock', sa.Integer(), nullable=True),
    sa.Column('sizes', postgresql.ARRAY(sa.String(length=10)), nullable=True),
    sa.Column('colors', postgresql.ARRAY(sa.String(length=50)), nullable=True),
    sa.Column('created_at', sa.DateTime(timezone=True), server_default=sa.text('now()'), nullable=True),
    sa.Column('updated_at', sa.DateTime(timezone=True), nullable=True),
    sa.ForeignKeyConstraint(['brand_id'], ['brands.id'], name=op.f('fk_products_brand_id_brands')),
    sa.PrimaryKeyConstraint('id', name=op.f('pk_products'))
    )
    op.create_table('favorites',
    sa.Column('user_id', UUIDColumn(length=36), nullable=False), # Changed: directly use UUIDColumn
    sa.Column('product_id', UUIDColumn(length=36), nullable=False), # Changed: directly use UUIDColumn
    sa.Column('created_at', sa.DateTime(timezone=True), server_default=sa.text('now()'), nullable=True),
    sa.ForeignKeyConstraint(['product_id'], ['products.id'], name=op.f('fk_favorites_product_id_products')),
    sa.ForeignKeyConstraint(['user_id'], ['users.id'], name=op.f('fk_favorites_user_id_users')),
    sa.PrimaryKeyConstraint('user_id', 'product_id', name=op.f('pk_favorites'))
    )
    op.create_table('transactions',
    sa.Column('id', UUIDColumn(length=36), nullable=False), # Changed: directly use UUIDColumn
    sa.Column('user_id', UUIDColumn(length=36), nullable=True), # Changed: directly use UUIDColumn
    sa.Column('product_id', UUIDColumn(length=36), nullable=False), # Changed: directly use UUIDColumn
    sa.Column('customer_name', sa.String(length=255), nullable=False),
    sa.Column('shipping_address', sa.Text(), nullable=False),
    sa.Column('payment_method', sa.String(length=50), nullable=False),
    sa.Column('transaction_status', sa.String(length=50), nullable=False),
    sa.Column('purchased_size', sa.String(length=10), nullable=False),
    sa.Column('purchased_color', sa.String(length=50), nullable=False),
    sa.Column('transaction_date', sa.DateTime(timezone=True), server_default=sa.text('now()'), nullable=True),
    sa.Column('updated_at', sa.DateTime(timezone=True), nullable=True),
    sa.ForeignKeyConstraint(['product_id'], ['products.id'], name=op.f('fk_transactions_product_id_products')),
    sa.ForeignKeyConstraint(['user_id'], ['users.id'], name=op.f('fk_transactions_user_id_users')),
    sa.PrimaryKeyConstraint('id', name=op.f('pk_transactions'))
    )
    # ### end Alembic commands ###


def downgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_table('transactions')
    op.drop_table('favorites')
    op.drop_table('products')
    op.drop_table('users')
    op.drop_table('inspirations')
    op.drop_table('brands')
    # ### end Alembic commands ###
```

## File: `wearspace_app\alembic\versions\README.txt`

```
Placeholder for alembic versions
```

## File: `wearspace_app\models\brand.py`

```
# your_project_name/models/brand.py
import uuid
from sqlalchemy import Column, DateTime, String
from sqlalchemy.sql import func
from sqlalchemy.orm import relationship
from .meta import Base, UUIDColumn

class Brand(Base):
    __tablename__ = 'brands'
    id = Column(UUIDColumn, primary_key=True, default=uuid.uuid4)
    name = Column(String(255), unique=True, nullable=False)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())

    products = relationship('Product', back_populates='brand', lazy=True)
```

## File: `wearspace_app\models\favorite.py`

```
# your_project_name/models/favorite.py
import uuid
from sqlalchemy import Column, DateTime, ForeignKey
from sqlalchemy.sql import func
from sqlalchemy.orm import relationship
from .meta import Base, UUIDColumn # Import UUIDColumn

class Favorite(Base):
    __tablename__ = 'favorites'
    user_id = Column(UUIDColumn, ForeignKey('users.id'), primary_key=True)
    product_id = Column(UUIDColumn, ForeignKey('products.id'), primary_key=True)
    created_at = Column(DateTime(timezone=True), server_default=func.now())

    user = relationship('User', back_populates='favorites')
    product = relationship('Product', back_populates='favorites')
```

## File: `wearspace_app\models\inspiration.py`

```
# your_project_name/models/inspiration.py
import uuid
from sqlalchemy import Column, DateTime, Text, String
from sqlalchemy.sql import func
from .meta import Base, UUIDColumn

class Inspiration(Base):
    __tablename__ = 'inspirations'
    id = Column(UUIDColumn, primary_key=True, default=uuid.uuid4)
    title = Column(String(255), nullable=False)
    description = Column(Text)
    image_url = Column(String(255))
    tag = Column(String(100))
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())
```

## File: `wearspace_app\models\meta.py`

```
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.schema import MetaData
from sqlalchemy.types import TypeDecorator, CHAR
import uuid

# Recommended naming convention used by Alembic, as various different database
# providers will autogenerate vastly different names making migrations more
# difficult. See: http://alembic.zzzcomputing.com/en/latest/naming.html
NAMING_CONVENTION = {
    "ix": "ix_%(column_0_label)s",
    "uq": "uq_%(table_name)s_%(column_0_name)s",
    "ck": "ck_%(table_name)s_%(constraint_name)s",
    "fk": "fk_%(table_name)s_%(column_0_name)s_%(referred_table_name)s",
    "pk": "pk_%(table_name)s"
}

metadata = MetaData(naming_convention=NAMING_CONVENTION)
Base = declarative_base(metadata=metadata)

class UUIDColumn(TypeDecorator):
    """
    UUIDType for SQLAlchemy, stores UUIDs as CHAR(32) and converts them to/from uuid.UUID objects.
    """
    impl = CHAR(36) # UUID string format is 36 characters (e.g., 'xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx')
    cache_ok = True

    def process_bind_param(self, value, dialect):
        if value is None:
            return value
        return str(value) # Convert UUID object to string

    def process_result_value(self, value, dialect):
        if value is None:
            return value
        return uuid.UUID(value) # Convert string to UUID object

```

## File: `wearspace_app\models\product.py`

```
# your_project_name/models/product.py
import uuid
from sqlalchemy import Column, DateTime, Text, Integer, String, DECIMAL, ForeignKey
from sqlalchemy.dialects.postgresql import ARRAY
from sqlalchemy.sql import func
from sqlalchemy.orm import relationship
from .meta import Base, UUIDColumn # Import UUIDColumn

class Product(Base):
    __tablename__ = 'products'
    id = Column(UUIDColumn, primary_key=True, default=uuid.uuid4)
    name = Column(String(255), nullable=False)
    brand_id = Column(UUIDColumn, ForeignKey('brands.id'), nullable=False)
    price = Column(DECIMAL(10, 2), nullable=False)
    description = Column(Text)
    image_url = Column(String(255))
    material = Column(String(100))
    category = Column(String(100))
    stock = Column(Integer, default=0)
    sizes = Column(ARRAY(String(10)))
    colors = Column(ARRAY(String(50)))
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())

    brand = relationship('Brand', back_populates='products')
    transactions = relationship('Transaction', back_populates='product', lazy=True)
    favorites = relationship('Favorite', back_populates='product', lazy=True)
```

## File: `wearspace_app\models\transaction.py`

```
# your_project_name/models/transaction.py
import uuid
from sqlalchemy import Column, DateTime, Text, Integer, String, DECIMAL, ForeignKey
from sqlalchemy.sql import func
from sqlalchemy.orm import relationship
from .meta import Base, UUIDColumn # Import UUIDColumn

class Transaction(Base):
    __tablename__ = 'transactions'
    id = Column(UUIDColumn, primary_key=True, default=uuid.uuid4)
    user_id = Column(UUIDColumn, ForeignKey('users.id'))
    product_id = Column(UUIDColumn, ForeignKey('products.id'), nullable=False)
    customer_name = Column(String(255), nullable=False)
    shipping_address = Column(Text, nullable=False)
    payment_method = Column(String(50), nullable=False)
    transaction_status = Column(String(50), nullable=False, default='Menunggu Pembayaran')
    purchased_size = Column(String(10), nullable=False)
    purchased_color = Column(String(50), nullable=False)
    transaction_date = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())

    user = relationship('User', back_populates='transactions')
    product = relationship('Product', back_populates='transactions')
```

## File: `wearspace_app\models\user.py`

```
# your_project_name/models/user.py
import uuid
from sqlalchemy import Column, DateTime, Text, String
from sqlalchemy.sql import func
from sqlalchemy.orm import relationship
from .meta import Base, UUIDColumn
from bcrypt import hashpw, gensalt, checkpw

class User(Base):
    __tablename__ = 'users'
    id = Column(UUIDColumn, primary_key=True, default=uuid.uuid4)
    email = Column(String(255), unique=True, nullable=False)
    hashed_password = Column(String(255), nullable=False)
    phone = Column(String(20))
    address = Column(Text)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())

    transactions = relationship('Transaction', back_populates='user', lazy=True)
    favorites = relationship('Favorite', back_populates='user', lazy=True)

    def set_password(self, password):
        self.hashed_password = hashpw(password.encode('utf-8'), gensalt()).decode('utf-8')

    def check_password(self, password):
        return checkpw(password.encode('utf-8'), self.hashed_password.encode('utf-8'))
```

## File: `wearspace_app\models\__init__.py`

```
from sqlalchemy import engine_from_config
from sqlalchemy.orm import sessionmaker
from sqlalchemy.orm import configure_mappers
import zope.sqlalchemy

# import or define all models here to ensure they are attached to the
# Base.metadata prior to any initialization routines
from .user import User
from .transaction import Transaction
from .brand import Brand
from .product import Product
from .favorite import Favorite
from .inspiration import Inspiration

from .meta import Base, UUIDColumn  # Import Base and UUIDColumn

# run configure_mappers after defining all of the models to ensure
# all relationships can be setup
configure_mappers()


def get_engine(settings, prefix='sqlalchemy.'):
    return engine_from_config(settings, prefix)


def get_session_factory(engine):
    factory = sessionmaker()
    factory.configure(bind=engine)
    return factory


def get_tm_session(session_factory, transaction_manager):
    """
    Get a ``sqlalchemy.orm.Session`` instance backed by a transaction.

    This function will hook the session to the transaction manager which
    will take care of committing any changes.

    - When using pyramid_tm it will automatically be committed or aborted
      depending on whether an exception is raised.

    - When using scripts you should wrap the session in a manager yourself.
      For example::

          import transaction

          engine = get_engine(settings)
          session_factory = get_session_factory(engine)
          with transaction.manager:
              dbsession = get_tm_session(session_factory, transaction.manager)

    """
    dbsession = session_factory()
    zope.sqlalchemy.register(
        dbsession, transaction_manager=transaction_manager)
    return dbsession


def includeme(config):
    """
    Initialize the model for a Pyramid app.

    Activate this setup using ``config.include('wearspace_app.models')``.

    """
    settings = config.get_settings()
    settings['tm.manager_hook'] = 'pyramid_tm.explicit_manager'

    # use pyramid_tm to hook the transaction lifecycle to the request
    config.include('pyramid_tm')

    # use pyramid_retry to retry a request when transient exceptions occur
    config.include('pyramid_retry')

    session_factory = get_session_factory(get_engine(settings))
    config.registry['dbsession_factory'] = session_factory

    # make request.dbsession available for use in Pyramid
    config.add_request_method(
        # r.tm is the transaction manager used by pyramid_tm
        lambda r: get_tm_session(session_factory, r.tm),
        'dbsession',
        reify=True
    )

```

## File: `wearspace_app\scripts\initialize_db.py`

```
import argparse
import sys
import uuid
from datetime import datetime

from pyramid.paster import bootstrap, setup_logging
from sqlalchemy.exc import OperationalError
import transaction # Import transaction explicitly if you want to control it manually outside Pyramid's tm

from ..models import (
    User,
    Brand,
    Product,
    Transaction,
    Favorite,
    Inspiration,
)

def setup_models(dbsession):
    """
    Add sample data to the database for Wearspace App.
    """
    print("🚀 Initializing Wearspace App database with sample data...")

    # Generate fresh, valid UUIDs for all sample data
    user_admin_id = uuid.uuid4()
    user_customer_id = uuid.uuid4()
    brand_nike_id = uuid.uuid4()
    brand_adidas_id = uuid.uuid4()
    product_shoe_id = uuid.uuid4()
    product_tshirt_id = uuid.uuid4()
    transaction_1_id = uuid.uuid4()
    transaction_2_id = uuid.uuid4()
    inspiration_1_id = uuid.uuid4()
    inspiration_2_id = uuid.uuid4()

    # --- Sample Users ---
    user_admin = User(
        id=user_admin_id,
        email="admin@wearspace.com",
        phone="081234567890",
        address="Jl. Admin No. 1, Jakarta"
    )
    user_admin.set_password("adminpass")
    dbsession.add(user_admin)

    user_customer = User(
        id=user_customer_id,
        email="customer@wearspace.com",
        phone="087654321000",
        address="Jl. Pelanggan No. 5, Bandung"
    )
    user_customer.set_password("customerpass")
    dbsession.add(user_customer)

    # --- Sample Brands ---
    brand_nike = Brand(
        id=brand_nike_id,
        name="Nike"
    )
    dbsession.add(brand_nike)

    brand_adidas = Brand(
        id=brand_adidas_id,
        name="Adidas"
    )
    dbsession.add(brand_adidas)

    # --- Sample Products ---
    product_shoe = Product(
        id=product_shoe_id,
        name="Nike Air Max 270",
        brand_id=brand_nike_id,
        price=150.00,
        description="Comfortable and stylish running shoes.",
        image_url="https://example.com/nike_airmax.jpg",
        material="Mesh, Rubber",
        category="Footwear",
        stock=50,
        sizes=['US 7', 'US 8', 'US 9', 'US 10'],
        colors=['Black', 'White', 'Red']
    )
    dbsession.add(product_shoe)

    product_tshirt = Product(
        id=product_tshirt_id,
        name="Adidas Trefoil T-Shirt",
        brand_id=brand_adidas_id,
        price=30.00,
        description="Classic cotton t-shirt with Adidas logo.",
        image_url="https://example.com/adidas_tshirt.jpg",
        material="Cotton",
        category="Apparel",
        stock=100,
        sizes=['S', 'M', 'L', 'XL'],
        colors=['Blue', 'Black']
    )
    dbsession.add(product_tshirt)

    # --- Sample Transactions ---
    transaction_1 = Transaction(
        id=transaction_1_id,
        user_id=user_customer_id,
        product_id=product_shoe_id,
        customer_name="John Doe",
        shipping_address="123 Main St, Anytown, USA",
        payment_method="Credit Card",
        transaction_status="Berhasil",
        purchased_size="US 9",
        purchased_color="Black",
        transaction_date=datetime(2025, 5, 20, 10, 30, 0)
    )
    dbsession.add(transaction_1)

    transaction_2 = Transaction(
        id=transaction_2_id,
        user_id=None, # Contoh transaksi tanpa user terdaftar (guest checkout)
        product_id=product_tshirt_id,
        customer_name="Jane Smith",
        shipping_address="456 Oak Ave, Othercity, USA",
        payment_method="PayPal",
        transaction_status="Menunggu Pembayaran",
        purchased_size="M",
        purchased_color="Blue",
        transaction_date=datetime(2025, 5, 25, 14, 0, 0)
    )
    dbsession.add(transaction_2)

    # --- Sample Favorites ---
    favorite_1 = Favorite(
        user_id=user_customer_id,
        product_id=product_shoe_id,
        created_at=datetime(2025, 5, 18, 9, 0, 0)
    )
    dbsession.add(favorite_1)

    # --- Sample Inspirations ---
    inspiration_1 = Inspiration(
        id=inspiration_1_id,
        title="Summer Style Guide",
        description="Latest trends for summer fashion.",
        image_url="https://example.com/summer_style.jpg",
        tag="Summer, Fashion, Trends",
        created_at=datetime(2025, 4, 1, 10, 0, 0)
    )
    dbsession.add(inspiration_1)

    inspiration_2 = Inspiration(
        id=inspiration_2_id,
        title="Sportswear Essentials",
        description="Must-have items for your workout.",
        image_url="https://example.com/sportswear.jpg",
        tag="Sport, Fitness, Essentials",
        created_at=datetime(2025, 4, 15, 11, 0, 0)
    )
    dbsession.add(inspiration_2)


def parse_args(argv):
    parser = argparse.ArgumentParser()
    parser.add_argument(
        'config_uri',
        help='Configuration file, e.g., development.ini',
    )
    return parser.parse_args(argv[1:])


def main(argv=sys.argv):
    args = parse_args(argv)
    setup_logging(args.config_uri)

    env = None # Initialize env to None outside try block
    try:
        env = bootstrap(args.config_uri)
        with env['request'].tm: # This context manager automatically handles commit/rollback
            dbsession = env['request'].dbsession
            setup_models(dbsession)
            print("✅ Sample data for Wearspace App inserted successfully.")
    except OperationalError as err:
        print("❌ OperationalError:", err)
        print('''
Database connection failed. The problem might be caused by one of the following:

1. You may need to initialize your database tables with `alembic upgrade head`.
   Make sure you have run Alembic migrations.

2. Your database server may not be running or misconfigured. Check that the
   database server referred to by the "sqlalchemy.url" setting in
   your "development.ini" file is running and accessible.
        ''')
        # pyramid_tm will automatically abort the transaction if an OperationalError occurs
        # so explicit abort() is not strictly needed here for this error type.
    except Exception as e:
        print(f"An unexpected error occurred: {e}")
        # For general exceptions, `with env['request'].tm:` should still handle rollback.
        # Re-raise the exception to see its full traceback if it's not OperationalError
        raise
```

## File: `wearspace_app\scripts\__init__.py`

```
# package

```

## File: `wearspace_app\static\theme.css`

```
@import url(//fonts.googleapis.com/css?family=Open+Sans:300,400,600,700);
body {
  font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
  font-weight: 300;
  color: #ffffff;
  background: #bc2131;
}
h1,
h2,
h3,
h4,
h5,
h6 {
  font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
  font-weight: 300;
}
p {
  font-weight: 300;
}
.font-normal {
  font-weight: 400;
}
.font-semi-bold {
  font-weight: 600;
}
.font-bold {
  font-weight: 700;
}
.starter-template {
  margin-top: 250px;
}
.starter-template .content {
  margin-left: 10px;
}
.starter-template .content h1 {
  margin-top: 10px;
  font-size: 60px;
}
.starter-template .content h1 .smaller {
  font-size: 40px;
  color: #f2b7bd;
}
.starter-template .content .lead {
  font-size: 25px;
  color: #f2b7bd;
}
.starter-template .content .lead .font-normal {
  color: #ffffff;
}
.starter-template .links {
  float: right;
  right: 0;
  margin-top: 125px;
}
.starter-template .links ul {
  display: block;
  padding: 0;
  margin: 0;
}
.starter-template .links ul li {
  list-style: none;
  display: inline;
  margin: 0 10px;
}
.starter-template .links ul li:first-child {
  margin-left: 0;
}
.starter-template .links ul li:last-child {
  margin-right: 0;
}
.starter-template .links ul li.current-version {
  color: #f2b7bd;
  font-weight: 400;
}
.starter-template .links ul li a, a {
  color: #f2b7bd;
  text-decoration: underline;
}
.starter-template .links ul li a:hover, a:hover {
  color: #ffffff;
  text-decoration: underline;
}
.starter-template .links ul li .icon-muted {
  color: #eb8b95;
  margin-right: 5px;
}
.starter-template .links ul li:hover .icon-muted {
  color: #ffffff;
}
.starter-template .copyright {
  margin-top: 10px;
  font-size: 0.9em;
  color: #f2b7bd;
  text-transform: lowercase;
  float: right;
  right: 0;
}
@media (max-width: 1199px) {
  .starter-template .content h1 {
    font-size: 45px;
  }
  .starter-template .content h1 .smaller {
    font-size: 30px;
  }
  .starter-template .content .lead {
    font-size: 20px;
  }
}
@media (max-width: 991px) {
  .starter-template {
    margin-top: 0;
  }
  .starter-template .logo {
    margin: 40px auto;
  }
  .starter-template .content {
    margin-left: 0;
    text-align: center;
  }
  .starter-template .content h1 {
    margin-bottom: 20px;
  }
  .starter-template .links {
    float: none;
    text-align: center;
    margin-top: 60px;
  }
  .starter-template .copyright {
    float: none;
    text-align: center;
  }
}
@media (max-width: 767px) {
  .starter-template .content h1 .smaller {
    font-size: 25px;
    display: block;
  }
  .starter-template .content .lead {
    font-size: 16px;
  }
  .starter-template .links {
    margin-top: 40px;
  }
  .starter-template .links ul li {
    display: block;
    margin: 0;
  }
  .starter-template .links ul li .icon-muted {
    display: none;
  }
  .starter-template .copyright {
    margin-top: 20px;
  }
}

```

## File: `wearspace_app\templates\404.jinja2`

```
{% extends "layout.jinja2" %}

{% block content %}
<div class="content">
  <h1><span class="font-semi-bold">Pyramid</span> <span class="smaller">Alchemy scaffold</span></h1>
  <p class="lead"><span class="font-semi-bold">404</span> Page Not Found</p>
</div>
{% endblock content %}

```

## File: `wearspace_app\templates\layout.jinja2`

```
<!DOCTYPE html>
<html lang="{{request.locale_name}}">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="pyramid web application">
    <meta name="author" content="Pylons Project">
    <link rel="shortcut icon" href="{{request.static_url('wearspace_app:static/pyramid-16x16.png')}}">

    <title>Cookiecutter Alchemy project for the Pyramid Web Framework</title>

    <!-- Bootstrap core CSS -->
    <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">

    <!-- Custom styles for this scaffold -->
    <link href="{{request.static_url('wearspace_app:static/theme.css')}}" rel="stylesheet">

    <!-- HTML5 shiv and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
      <script src="//oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js" integrity="sha384-0s5Pv64cNZJieYFkXYOTId2HMA2Lfb6q2nAcx2n0RTLUnCAoTTsS0nKEO27XyKcY" crossorigin="anonymous"></script>
      <script src="//oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js" integrity="sha384-ZoaMbDF+4LeFxg6WdScQ9nnR1QC2MIRxA1O9KWEXQwns1G8UNyIEZIQidzb0T1fo" crossorigin="anonymous"></script>
    <![endif]-->
  </head>

  <body>

    <div class="starter-template">
      <div class="container">
        <div class="row">
          <div class="col-md-2">
            <img class="logo img-responsive" src="{{request.static_url('wearspace_app:static/pyramid.png') }}" alt="pyramid web framework">
          </div>
          <div class="col-md-10">
            {% block content %}
                <p>No content</p>
            {% endblock content %}
          </div>
        </div>
        <div class="row">
          <div class="links">
            <ul>
              <li><i class="glyphicon glyphicon-cog icon-muted"></i><a href="https://github.com/Pylons/pyramid">Github Project</a></li>
              <li><i class="glyphicon glyphicon-globe icon-muted"></i><a href="https://webchat.freenode.net/?channels=pyramid">IRC Channel</a></li>
              <li><i class="glyphicon glyphicon-home icon-muted"></i><a href="https://pylonsproject.org">Pylons Project</a></li>
            </ul>
          </div>
        </div>
        <div class="row">
          <div class="copyright">
            Copyright &copy; Pylons Project
          </div>
        </div>
      </div>
    </div>


    <!-- Bootstrap core JavaScript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="//code.jquery.com/jquery-1.12.4.min.js" integrity="sha256-ZosEbRLbNQzLpnKIkEdrPv7lOy9C27hHQ+Xp8a4MxAQ=" crossorigin="anonymous"></script>
    <script src="//maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>
  </body>
</html>

```

## File: `wearspace_app\templates\mytemplate.jinja2`

```
{% extends "layout.jinja2" %}

{% block content %}
<div class="content">
  <h1><span class="font-semi-bold">Pyramid</span> <span class="smaller">Alchemy project</span></h1>
  <p class="lead">Welcome to <span class="font-normal">{{project}}</span>, a&nbsp;Pyramid application generated&nbsp;by<br><span class="font-normal">Cookiecutter</span>.</p>
</div>
{% endblock content %}
```

## File: `wearspace_app\views\api.py`

```
import uuid
from pyramid.view import view_config
from pyramid.response import Response
from webob.exc import HTTPNotFound, HTTPBadRequest, HTTPInternalServerError, HTTPUnauthorized, HTTPConflict
from sqlalchemy.exc import IntegrityError
from sqlalchemy import func
from ..models import (
    User, Brand, Product, Transaction, Favorite, Inspiration
)
from ..models.meta import UUIDColumn # Pastikan ini benar
from pyramid.security import remember, forget # Hapus authenticated_userid dari sini
from datetime import datetime
from decimal import Decimal

# Helper: validasi field kosong
def require_fields(data, required_fields):
    missing = [f for f in required_fields if not data.get(f)]
    if missing:
        # Langsung raise exception HTTP
        raise HTTPBadRequest(json={'error': f'Missing fields: {", ".join(missing)}'})

# Helper: Serialisasi objek
def serialize_object(obj):
    if not obj:
        return None
    data = {c.name: getattr(obj, c.name) for c in obj.__table__.columns}
    for key, value in data.items():
        if isinstance(value, uuid.UUID):
            data[key] = str(value)
        elif isinstance(value, datetime):
            if value:
                data[key] = value.isoformat()
        elif isinstance(value, Decimal):
            data[key] = float(value)
    if 'hashed_password' in data: # Hapus hashed_password untuk keamanan
        del data['hashed_password']
    return data

# --- Authentication and User Management ---

@view_config(route_name='register', request_method='POST', renderer='json')
def register_user(request):
    data = request.json_body
    
    try:
        require_fields(data, ['email', 'password'])
    except HTTPBadRequest as e: # Tangkap exception yang di-raise helper
        raise e

    email = data['email']
    password = data['password']

    try:
        existing_user = request.dbsession.query(User).filter_by(email=email).first()
        if existing_user:
            raise HTTPConflict(json={'error': 'User with this email already exists.'}) # Gunakan HTTPConflict

        user = User(email=email)
        user.set_password(password)
        user.phone = data.get('phone')
        user.address = data.get('address')
        user.username = data.get('username') # Pastikan username juga ditambahkan jika ada di model User

        request.dbsession.add(user)
        request.dbsession.flush()
        return Response(json={'message': 'User registered successfully!', 'user': serialize_object(user)}, status=201)
    except IntegrityError:
        request.dbsession.rollback()
        # Jika ada unique constraint lain selain email, bisa juga tertangkap di sini
        raise HTTPBadRequest(json={'error': 'User with this email already exists or other integrity error.'})
    except HTTPConflict as e: # Tangkap HTTPConflict yang kita raise
        raise e
    except Exception as e:
        request.dbsession.rollback()
        raise HTTPInternalServerError(f'Failed to register user: {e}')

@view_config(route_name='login', request_method='POST', renderer='json')
def login_user(request):
    data = request.json_body

    try:
        require_fields(data, ['email', 'password'])
    except HTTPBadRequest as e:
        raise e

    email = data['email']
    password = data['password']

    user = request.dbsession.query(User).filter_by(email=email).first()
    if not user or not user.check_password(password):
        raise HTTPUnauthorized(json={'error': 'Invalid credentials.'})

    # Membuat cookie autentikasi AuthTkt
    # user.id harus berupa string karena itu yang diharapkan oleh AuthTktAuthenticationPolicy
    headers = remember(request, str(user.id))

    response = Response(json={
        'message': 'Login successful!',
        'user': serialize_object(user),
        # Opsional: untuk verifikasi di sisi klien bahwa user terautentikasi
        'authenticated_userid': request.authenticated_userid # Gunakan request.authenticated_userid
    })
    response.headers.extend(headers) # Menambahkan header Set-Cookie ke response
    return response

@view_config(route_name='logout', request_method='POST', renderer='json')
def logout_user(request):
    # Menghapus cookie autentikasi AuthTkt
    headers = forget(request)
    response = Response(json={'message': 'Logged out successfully.'})
    response.headers.extend(headers) # Menambahkan header untuk menghapus cookie ke response
    return response

@view_config(route_name='users', request_method='GET', renderer='json')
def get_users(request):
    users = request.dbsession.query(User).all()
    return [serialize_object(user) for user in users]

@view_config(route_name='user_by_id', request_method='GET', renderer='json')
def get_user(request):
    user_id = request.matchdict['id']
    try:
        user = request.dbsession.query(User).get(uuid.UUID(user_id))
    except ValueError:
        raise HTTPBadRequest(json={'error': 'Invalid UUID format for user ID.'})
    if not user:
        raise HTTPNotFound(json={'error': 'User not found.'})
    return serialize_object(user)

@view_config(route_name='user_by_id', request_method='PUT', renderer='json')
def update_user(request):
    user_id = request.matchdict['id']
    data = request.json_body
    try:
        user = request.dbsession.query(User).get(uuid.UUID(user_id))
    except ValueError:
        raise HTTPBadRequest(json={'error': 'Invalid UUID format for user ID.'})
    if not user:
        raise HTTPNotFound(json={'error': 'User not found.'})

    try:
        if 'password' in data:
            user.set_password(data['password'])
            del data['password'] # Hapus password dari data agar tidak di-setattr lagi

        for key, value in data.items():
            if hasattr(user, key):
                setattr(user, key, value)
        request.dbsession.flush()
        return serialize_object(user)
    except IntegrityError:
        request.dbsession.rollback()
        raise HTTPConflict(json={'error': 'Email already in use or other integrity error.'}) # Gunakan HTTPConflict
    except Exception as e:
        request.dbsession.rollback()
        raise HTTPInternalServerError(f'Failed to update user: {e}')

@view_config(route_name='user_by_id', request_method='DELETE', renderer='json')
def delete_user(request):
    user_id = request.matchdict['id']
    try:
        user = request.dbsession.query(User).get(uuid.UUID(user_id))
    except ValueError:
        raise HTTPBadRequest(json={'error': 'Invalid UUID format for user ID.'})
    if not user:
        raise HTTPNotFound(json={'error': 'User not found.'})

    request.dbsession.delete(user)
    return Response(json={'message': 'User deleted successfully'}, status=204)

# --- Brand Management ---

@view_config(route_name='brands', request_method='GET', renderer='json')
def get_brands(request):
    brands = request.dbsession.query(Brand).all()
    return [serialize_object(brand) for brand in brands]

@view_config(route_name='brands', request_method='POST', renderer='json')
def create_brand(request):
    data = request.json_body
    try:
        require_fields(data, ['name'])
    except HTTPBadRequest as e:
        raise e

    try:
        brand = Brand(name=data['name'])
        request.dbsession.add(brand)
        request.dbsession.flush()
        return Response(json=serialize_object(brand), status=201)
    except IntegrityError:
        request.dbsession.rollback()
        raise HTTPConflict(json={'error': 'Brand with this name already exists.'}) # Gunakan HTTPConflict
    except Exception as e:
        request.dbsession.rollback()
        raise HTTPInternalServerError(f'Failed to create brand: {e}')

@view_config(route_name='brand_by_id', request_method='PUT', renderer='json')
def update_brand(request):
    brand_id = request.matchdict['id']
    data = request.json_body
    try:
        brand = request.dbsession.query(Brand).get(uuid.UUID(brand_id))
    except ValueError:
        raise HTTPBadRequest(json={'error': 'Invalid UUID format for brand ID.'})
    if not brand:
        raise HTTPNotFound(json={'error': 'Brand not found.'})

    try:
        if 'name' in data:
            brand.name = data['name']
        request.dbsession.flush()
        return serialize_object(brand)
    except IntegrityError:
        request.dbsession.rollback()
        raise HTTPConflict(json={'error': 'Brand name already exists.'}) # Gunakan HTTPConflict
    except Exception as e:
        request.dbsession.rollback()
        raise HTTPInternalServerError(f'Failed to update brand: {e}')

@view_config(route_name='brand_by_id', request_method='DELETE', renderer='json')
def delete_brand(request):
    brand_id = request.matchdict['id']
    try:
        brand = request.dbsession.query(Brand).get(uuid.UUID(brand_id))
    except ValueError:
        raise HTTPBadRequest(json={'error': 'Invalid UUID format for brand ID.'})
    if not brand:
        raise HTTPNotFound(json={'error': 'Brand not found.'})

    request.dbsession.delete(brand)
    return Response(json={'message': 'Brand deleted successfully'}, status=204)

# --- Product Management ---

@view_config(route_name='products', request_method='GET', renderer='json')
def get_products(request):
    products = request.dbsession.query(Product).all()
    return [serialize_object(p) for p in products]

@view_config(route_name='products', request_method='POST', renderer='json')
def create_product(request):
    data = request.json_body
    required_fields = ['name', 'brand_id', 'price', 'stock', 'sizes', 'colors']
    
    try:
        require_fields(data, required_fields)
    except HTTPBadRequest as e:
        raise e

    try:
        brand_id_uuid = uuid.UUID(data['brand_id'])
        brand = request.dbsession.query(Brand).get(brand_id_uuid)
        if not brand:
            raise HTTPBadRequest(json={'error': 'Brand not found for the given brand_id.'})

        product = Product(
            name=data['name'],
            brand_id=brand_id_uuid,
            price=data['price'],
            stock=data['stock'],
            sizes=data['sizes'],
            colors=data['colors'],
            description=data.get('description'),
            image_url=data.get('image_url'),
            material=data.get('material'),
            category=data.get('category')
        )
        request.dbsession.add(product)
        request.dbsession.flush()
        return Response(json=serialize_object(product), status=201)
    except ValueError:
        raise HTTPBadRequest(json={'error': 'Invalid UUID format for brand ID.'})
    except Exception as e:
        request.dbsession.rollback()
        raise HTTPInternalServerError(f'Failed to create product: {e}')

@view_config(route_name='product_by_id', request_method='GET', renderer='json')
def get_product(request):
    product_id = request.matchdict['id']
    try:
        product = request.dbsession.query(Product).get(uuid.UUID(product_id))
    except ValueError:
        raise HTTPBadRequest(json={'error': 'Invalid UUID format for product ID.'})
    if not product:
        raise HTTPNotFound(json={'error': 'Product not found.'})
    return serialize_object(product)

@view_config(route_name='product_by_id', request_method='PUT', renderer='json')
def update_product(request):
    product_id = request.matchdict['id']
    data = request.json_body
    try:
        product = request.dbsession.query(Product).get(uuid.UUID(product_id))
    except ValueError:
        raise HTTPBadRequest(json={'error': 'Invalid UUID format for product ID.'})
    if not product:
        raise HTTPNotFound(json={'error': 'Product not found.'})

    try:
        if 'brand_id' in data:
            brand_id_uuid = uuid.UUID(data['brand_id'])
            brand = request.dbsession.query(Brand).get(brand_id_uuid)
            if not brand:
                raise HTTPBadRequest(json={'error': 'Brand not found for the given brand_id.'})
            product.brand_id = brand_id_uuid

        for key, value in data.items():
            if key not in ['brand_id'] and hasattr(product, key):
                setattr(product, key, value)

        request.dbsession.flush()
        return serialize_object(product)
    except ValueError:
        raise HTTPBadRequest(json={'error': 'Invalid UUID format provided.'})
    except Exception as e:
        request.dbsession.rollback()
        raise HTTPInternalServerError(f'Failed to update product: {e}')

@view_config(route_name='product_by_id', request_method='DELETE', renderer='json')
def delete_product(request):
    product_id = request.matchdict['id']
    try:
        product = request.dbsession.query(Product).get(uuid.UUID(product_id))
    except ValueError:
        raise HTTPBadRequest(json={'error': 'Invalid UUID format for product ID.'})
    if not product:
        raise HTTPNotFound(json={'error': 'Product not found.'})

    request.dbsession.delete(product)
    return Response(json={'message': 'Product deleted successfully'}, status=204)

# --- Transaction Management ---

@view_config(route_name='transactions', request_method='GET', renderer='json')
def get_transactions(request):
    transactions = request.dbsession.query(Transaction).all()
    serialized_transactions = []
    for t in transactions:
        t_data = serialize_object(t)
        if t.product:
            t_data['product'] = serialize_object(t.product)
        if t.user:
            t_data['user'] = serialize_object(t.user)
        serialized_transactions.append(t_data)
    return serialized_transactions

@view_config(route_name='transactions', request_method='POST', renderer='json')
def create_transaction(request):
    data = request.json_body
    required_fields = ['product_id', 'customer_name', 'shipping_address',
                       'payment_method', 'purchased_size', 'purchased_color']
    
    try:
        require_fields(data, required_fields)
    except HTTPBadRequest as e:
        raise e

    try:
        product_id_uuid = uuid.UUID(data['product_id'])
        product = request.dbsession.query(Product).get(product_id_uuid)
        if not product:
            raise HTTPBadRequest(json={'error': 'Product not found.'})

        if product.stock <= 0:
            raise HTTPBadRequest(json={'error': 'Product out of stock.'})

        product.stock -= 1

        user_id = None
        # Gunakan request.authenticated_userid untuk mendapatkan ID pengguna yang sedang login
        if request.authenticated_userid:
            user_id = uuid.UUID(request.authenticated_userid)

        transaction = Transaction(
            user_id=user_id, # user_id bisa None jika tidak ada yang login
            product_id=product_id_uuid,
            customer_name=data['customer_name'],
            shipping_address=data['shipping_address'],
            payment_method=data['payment_method'],
            purchased_size=data['purchased_size'],
            purchased_color=data['purchased_color'],
            transaction_status='Menunggu Pembayaran'
        )
        request.dbsession.add(transaction)
        request.dbsession.flush()

        return Response(json=serialize_object(transaction), status=201)
    except ValueError:
        raise HTTPBadRequest(json={'error': 'Invalid UUID format.'})
    except Exception as e:
        request.dbsession.rollback()
        raise HTTPInternalServerError(f'Failed to create transaction: {e}')

@view_config(route_name='transaction_by_id', request_method='GET', renderer='json')
def get_transaction(request):
    transaction_id = request.matchdict['id']
    try:
        transaction = request.dbsession.query(Transaction).get(uuid.UUID(transaction_id))
    except ValueError:
        raise HTTPBadRequest(json={'error': 'Invalid UUID format for transaction ID.'})
    if not transaction:
        raise HTTPNotFound(json={'error': 'Transaction not found.'})

    t_data = serialize_object(transaction)
    if transaction.product:
        t_data['product'] = serialize_object(transaction.product)
    if transaction.user:
        t_data['user'] = serialize_object(transaction.user)
    return t_data

@view_config(route_name='transaction_by_id', request_method='PUT', renderer='json')
def update_transaction_status(request):
    transaction_id = request.matchdict['id']
    data = request.json_body
    if 'transaction_status' not in data:
        raise HTTPBadRequest(json={'error': 'Transaction status is required for update.'})

    try:
        transaction = request.dbsession.query(Transaction).get(uuid.UUID(transaction_id))
    except ValueError:
        raise HTTPBadRequest(json={'error': 'Invalid UUID format for transaction ID.'})
    if not transaction:
        raise HTTPNotFound(json={'error': 'Transaction not found.'})

    valid_statuses = ['Menunggu Pembayaran', 'Berhasil', 'Dibatalkan']
    if data['transaction_status'] not in valid_statuses:
        raise HTTPBadRequest(json={'error': f"Invalid status. Must be one of: {', '.join(valid_statuses)}"})

    try:
        transaction.transaction_status = data['transaction_status']
        request.dbsession.flush()
        return serialize_object(transaction)
    except Exception as e:
        request.dbsession.rollback()
        raise HTTPInternalServerError(f'Failed to update transaction status: {e}')

@view_config(route_name='transaction_by_id', request_method='DELETE', renderer='json')
def delete_transaction(request):
    transaction_id = request.matchdict['id']
    try:
        transaction = request.dbsession.query(Transaction).get(uuid.UUID(transaction_id))
    except ValueError:
        raise HTTPBadRequest(json={'error': 'Invalid UUID format for transaction ID.'})
    if not transaction:
        raise HTTPNotFound(json={'error': 'Transaction not found.'})

    request.dbsession.delete(transaction)
    return Response(json={'message': 'Transaction deleted successfully'}, status=204)

# --- Favorite Management ---

@view_config(route_name='favorites', request_method='GET', renderer='json')
def get_favorites(request):
    # Mengambil ID pengguna yang sedang login
    user_id = request.authenticated_userid # Langsung pakai request.authenticated_userid
    if not user_id:
        raise HTTPUnauthorized(json={'error': 'Authentication required to view favorites.'})

    try:
        user_uuid = uuid.UUID(user_id)
    except ValueError:
        raise HTTPBadRequest(json={'error': 'Invalid UUID format for user ID in session.'})

    favorites = request.dbsession.query(Favorite).filter(Favorite.user_id == user_uuid).all()
    favorite_products = []
    for fav in favorites:
        if fav.product:
            favorite_products.append(serialize_object(fav.product))
    return favorite_products

@view_config(route_name='favorites', request_method='POST', renderer='json')
def add_favorite(request):
    # Mengambil ID pengguna yang sedang login
    user_id = request.authenticated_userid # Langsung pakai request.authenticated_userid
    if not user_id:
        raise HTTPUnauthorized(json={'error': 'Authentication required to add favorite.'})

    data = request.json_body
    try:
        require_fields(data, ['product_id'])
    except HTTPBadRequest as e:
        raise e

    try:
        user_uuid = uuid.UUID(user_id)
        product_uuid = uuid.UUID(data['product_id'])

        user = request.dbsession.query(User).get(user_uuid)
        product = request.dbsession.query(Product).get(product_uuid)
        if not user or not product:
            raise HTTPNotFound(json={'error': 'User or Product not found.'})

        existing_favorite = request.dbsession.query(Favorite).filter_by(
            user_id=user_uuid, product_id=product_uuid
        ).first()
        if existing_favorite:
            raise HTTPConflict(json={'error': 'Product already in favorites.'})

        favorite = Favorite(user_id=user_uuid, product_id=product_uuid)
        request.dbsession.add(favorite)
        request.dbsession.flush()
        return Response(json={'message': 'Product added to favorites'}, status=201)
    except ValueError:
        raise HTTPBadRequest(json={'error': 'Invalid UUID format.'})
    except IntegrityError:
        request.dbsession.rollback()
        # Jika ada unique constraint di database, ini akan terpicu
        raise HTTPConflict(json={'error': 'Product already in favorites (integrity constraint).'})
    except HTTPConflict as e: # Tangkap HTTPConflict yang kita raise
        raise e
    except Exception as e:
        request.dbsession.rollback()
        raise HTTPInternalServerError(f'Failed to add favorite: {e}')

@view_config(route_name='favorite_by_product_id', request_method='DELETE', renderer='json')
def remove_favorite(request):
    # Mengambil ID pengguna yang sedang login
    user_id = request.authenticated_userid # Langsung pakai request.authenticated_userid
    if not user_id:
        raise HTTPUnauthorized(json={'error': 'Authentication required to remove favorite.'})

    product_id = request.matchdict['product_id']
    try:
        user_uuid = uuid.UUID(user_id)
        product_uuid = uuid.UUID(product_id)
    except ValueError:
        raise HTTPBadRequest(json={'error': 'Invalid UUID format.'})

    favorite = request.dbsession.query(Favorite).filter_by(
        user_id=user_uuid, product_id=product_uuid
    ).first()
    if not favorite:
        raise HTTPNotFound(json={'error': 'Favorite not found.'})

    request.dbsession.delete(favorite)
    return Response(json={'message': 'Product removed from favorites'}, status=204)

# --- Inspiration Management ---

@view_config(route_name='inspirations', request_method='GET', renderer='json')
def get_inspirations(request):
    tag = request.params.get('tag')
    query = request.dbsession.query(Inspiration)
    if tag:
        query = query.filter(Inspiration.tag.ilike(f'%{tag}%'))
    inspirations = query.all()
    return [serialize_object(inspo) for inspo in inspirations]

@view_config(route_name='inspirations', request_method='POST', renderer='json')
def create_inspiration(request):
    data = request.json_body
    required_fields = ['title', 'description', 'image_url', 'tag']
    
    try:
        require_fields(data, required_fields)
    except HTTPBadRequest as e:
        raise e

    try:
        inspiration = Inspiration(
            title=data['title'],
            description=data['description'],
            image_url=data['image_url'],
            tag=data['tag']
        )
        request.dbsession.add(inspiration)
        request.dbsession.flush()
        return Response(json=serialize_object(inspiration), status=201)
    except Exception as e:
        request.dbsession.rollback()
        raise HTTPInternalServerError(f'Failed to create inspiration: {e}')

@view_config(route_name='inspiration_by_id', request_method='GET', renderer='json')
def get_inspiration(request):
    inspiration_id = request.matchdict['id']
    try:
        inspiration = request.dbsession.query(Inspiration).get(uuid.UUID(inspiration_id))
    except ValueError:
        raise HTTPBadRequest(json={'error': 'Invalid UUID format for inspiration ID.'})
    if not inspiration:
        raise HTTPNotFound(json={'error': 'Inspiration not found.'})
    return serialize_object(inspiration)

@view_config(route_name='inspiration_by_id', request_method='PUT', renderer='json')
def update_inspiration(request):
    inspiration_id = request.matchdict['id']
    data = request.json_body
    try:
        inspiration = request.dbsession.query(Inspiration).get(uuid.UUID(inspiration_id))
    except ValueError:
        raise HTTPBadRequest(json={'error': 'Invalid UUID format for inspiration ID.'})
    if not inspiration:
        raise HTTPNotFound(json={'error': 'Inspiration not found.'})

    try:
        for key, value in data.items():
            if hasattr(inspiration, key):
                setattr(inspiration, key, value)
        request.dbsession.flush()
        return serialize_object(inspiration)
    except Exception as e:
        request.dbsession.rollback()
        raise HTTPInternalServerError(f'Failed to update inspiration: {e}')

@view_config(route_name='inspiration_by_id', request_method='DELETE', renderer='json')
def delete_inspiration(request):
    inspiration_id = request.matchdict['id']
    try:
        inspiration = request.dbsession.query(Inspiration).get(uuid.UUID(inspiration_id))
    except ValueError:
        raise HTTPBadRequest(json={'error': 'Invalid UUID format for inspiration ID.'})
    if not inspiration:
        raise HTTPNotFound(json={'error': 'Inspiration not found.'})

    request.dbsession.delete(inspiration)
    return Response(json={'message': 'Inspiration deleted successfully'}, status=204)
```

## File: `wearspace_app\views\default.py`

```
from pyramid.response import Response
from pyramid.view import view_config

@view_config(route_name='home')
def home_view(request):
    return Response('Wearspace API', content_type='text/plain')
```

## File: `wearspace_app\views\notfound.py`

```
from pyramid.view import notfound_view_config


@notfound_view_config(renderer='../templates/404.jinja2')
def notfound_view(request):
    request.response.status = 404
    return {}

```

## File: `wearspace_app\views\__init__.py`

```

```

## File: `wearspace_app\cors.py`

```
# In a file called tweens.py or in the main file
from pyramid.response import Response
from pyramid.httpexceptions import HTTPForbidden

def cors_tween_factory(handler, registry):
    def cors_tween(request):
        # Allow specific origin (not *)
        allowed_origin = 'http://localhost:5173'

        if request.method == 'OPTIONS':
            # Preflight response
            response = request.response
            response.headers['Access-Control-Allow-Origin'] = allowed_origin
            response.headers['Access-Control-Allow-Credentials'] = 'true'
            response.headers['Access-Control-Allow-Methods'] = 'GET, POST, PUT, DELETE, OPTIONS'
            response.headers['Access-Control-Allow-Headers'] = 'Content-Type, Authorization'
            response.headers['Access-Control-Max-Age'] = '3600'
            
            return response

        # Actual response
        response = handler(request)
        response.headers['Access-Control-Allow-Origin'] = allowed_origin
        response.headers['Access-Control-Allow-Credentials'] = 'true'
        response.headers['Access-Control-Allow-Methods'] = 'GET, POST, PUT, DELETE, OPTIONS'
        response.headers['Access-Control-Allow-Headers'] = 'Content-Type, Authorization'
        
        return response

    return cors_tween
```

## File: `wearspace_app\pshell.py`

```
from . import models

def setup(env):
    request = env['request']

    # start a transaction
    request.tm.begin()

    # inject some vars into the shell builtins
    env['tm'] = request.tm
    env['dbsession'] = request.dbsession
    env['models'] = models

```

## File: `wearspace_app\routes.py`

```
# wearspace_app/routes.py
def includeme(config):
    config.add_static_view('static', 'static', cache_max_age=3600)
    config.add_route('home', '/')

    # API Routes for Users
    config.add_route('users', '/api/users')
    config.add_route('user_by_id', '/api/users/{id}')

    # --- API Routes for Auth (TAMBAHKAN INI) ---
    config.add_route('register', '/api/auth/register')
    config.add_route('login', '/api/auth/login')
    config.add_route('logout', '/api/auth/logout')
    # --------------------------------------------

    # API Routes for Brands
    config.add_route('brands', '/api/brands')
    config.add_route('brand_by_id', '/api/brands/{id}')

    # API Routes for Products
    config.add_route('products', '/api/products')
    config.add_route('product_by_id', '/api/products/{id}')

    # API Routes for Transactions
    config.add_route('transactions', '/api/transactions')
    config.add_route('transaction_by_id', '/api/transactions/{id}')

    # API Routes for Favorites
    config.add_route('favorites', '/api/favorites')
    config.add_route('favorite_by_product_id', '/api/favorites/{product_id}')

    # API Routes for Inspirations
    config.add_route('inspirations', '/api/inspirations')
    config.add_route('inspiration_by_id', '/api/inspirations/{id}')
```

## File: `wearspace_app\tests.py`

```

```

## File: `wearspace_app\__init__.py`

```
from pyramid.config import Configurator
from pyramid.session import SignedCookieSessionFactory
from pyramid.authentication import AuthTktAuthenticationPolicy
from pyramid.authorization import ACLAuthorizationPolicy
from sqlalchemy import engine_from_config
from .models.meta import Base
from .models import User # Import User model untuk callback auth
from pyramid.renderers import JSON
from .cors import cors_tween_factory
import uuid # Diperlukan untuk get_user_principals

# Callback untuk AuthTktAuthenticationPolicy
def get_user_principals(userid, request):
    # userid adalah string user ID yang disimpan di ticket
    try:
        user_uuid = uuid.UUID(userid)
        user = request.dbsession.query(User).get(user_uuid)
        if user:
            # Mengembalikan list principals. Contoh: ['user:{user_id}', 'group:users']
            # Untuk kasus sederhana, kita hanya mengembalikan user ID sebagai principal
            return [f'user:{user.id}']
        return None
    except ValueError:
        return None # Handle jika userid bukan UUID yang valid

def main(global_config, **settings):
    """ This function returns a Pyramid WSGI application. """

    config = Configurator(settings=settings)

    # 1. Konfigurasi CORS (harus di awal)
    config.add_tween('.cors_tween_factory')
    config.add_renderer('json', JSON(indent=4))

    # 2. Konfigurasi Session Factory (AuthTkt policy membutuhkan ini)
    session_secret = settings.get('session.secret', 'a_default_session_secret_for_dev') # Ganti dengan secret kuat
    session_factory = SignedCookieSessionFactory(session_secret)
    config.set_session_factory(session_factory)

    # 3. Konfigurasi Authentication dan Authorization Policy
    auth_secret = settings.get('auth.secret', 'a_default_auth_secret_for_dev') # Ganti dengan secret kuat
    authn_policy = AuthTktAuthenticationPolicy(
        auth_secret,
        callback=get_user_principals,
        hashalg='sha512',
        cookie_name='wearspace_auth',
        # secure=True, # Aktifkan di produksi dengan HTTPS
        # httponly=True, # Pastikan ini True untuk keamanan cookie
        # wildcard_domain=False # Aktifkan jika aplikasi di subdomain berbeda
    )
    authz_policy = ACLAuthorizationPolicy()

    config.set_authentication_policy(authn_policy)
    config.set_authorization_policy(authz_policy)

    # 4. Include other Pyramid extensions/modules
    config.include('pyramid_jinja2')
    # `pyramid_sqlalchemy` harus di-include sebelum `.models`
    # karena `.models` mungkin bergantung pada konfigurasi SQLAlchemy dari `pyramid_sqlalchemy`
    config.include('pyramid_sqlalchemy') # Ini akan mengatur dbsession dan engine
    config.include('pyramid_tm')
    config.include('pyramid_retry')

    # 5. Include your application's models and routes
    config.include('.models') # Ini akan memanggil includeme dari wearspace_app/models/__init__.py
    config.include('.routes') # Ini akan memanggil includeme dari wearspace_app/routes.py

    # 6. Scan views and other declaratively configured components
    config.scan()

    return config.make_wsgi_app()
```

